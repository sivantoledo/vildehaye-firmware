#include "config.h"

#ifndef USE_AX5031

#include <xdc/runtime/System.h>

#include "radio.h"

#include <ti/devices/DeviceFamily.h>
#include DeviceFamily_constructPath(driverlib/rf_mailbox.h)
#include DeviceFamily_constructPath(driverlib/rf_prop_mailbox.h)
#include DeviceFamily_constructPath(driverlib/rf_common_cmd.h)
#include DeviceFamily_constructPath(driverlib/rf_prop_cmd.h)

#include <ti/drivers/rf/RF.h>

#ifdef DeviceFamily_CC13X2
#include DeviceFamily_constructPath(rf_patches/rf_patch_cpe_prop.h)
#endif
#ifdef DeviceFamily_CC13X0
#include DeviceFamily_constructPath(rf_patches/rf_patch_cpe_genfsk.h)
#include DeviceFamily_constructPath(rf_patches/rf_patch_rfe_genfsk.h)
#include DeviceFamily_constructPath(rf_patches/rf_patch_cpe_sl_longrange.h)
#include DeviceFamily_constructPath(rf_patches/rf_patch_rfe_sl_longrange.h)
#include DeviceFamily_constructPath(rf_patches/rf_patch_mce_sl_longrange.h)
#endif

#ifdef MCU_CC13X0
//#include <rf_patches/rf_patch_cpe_genfsk.h>
//#include <rf_patches/rf_patch_rfe_genfsk.h>
//#include <rf_patches/rf_patch_cpe_lrm.h>
//#include <rf_patches/apply_lrm_mce_patch.h>
// got the file below from SVS on E2E
#include "apply_lrm_mce_patch.h"
//#include "rf_patch_cpe_genfsk.h"
//#include "rf_patch_rfe_genfsk.h"
#include "rf_patch_cpe_lrm.h"
#endif


#ifdef MCU_CC2650
#include "apply_patch.h"
#include "apply_genfsk_rfe_patch.h"
#include "apply_genfsk_mce_patch.h"
#endif

#include "rf_queue_pointer.h"
#include "receive.h"
//#include "radio_setup.h"

/*********************************************************************************/

#define DEVIATION_STEP_SIZE  250

/*********************************************************************************/
/* A COLLECTION OF SYNC WORDS                                                    */
/*********************************************************************************/

#define SYNCWORD16_SILABS 0x2DD4
#define SYNCWORD32_SILABS 0x5A0FBE66
#define SYNCWORD16_TI_WOR 0xD391

/*********************************************************************************/
/* storage of parameters for setups                                              */
/*********************************************************************************/

static int8_t  dbmForSetup[MAX_RADIO_SETUPS];    // remember for base stations
//static uint8_t packet_format[MAX_RADIO_SETUPS];
static uint8_t loForSetup[MAX_RADIO_SETUPS];

//*********************************************************************************
// These settings have been generated for use with TI-RTOS and cc13xxware
//
// Generated by SmartRF Studio version 2.4.0
// Tested for TI-RTOS version tirtos_simplelink_2_20_xx
// Device: CC13xx Rev. 2.1
//
//*********************************************************************************


//*********************************************************************************
// Parameter summary
// Address: aa-bb
// Frequency: 868.00000 MHz
// Data Format: Serial mode disable
// Deviation: 25.000 kHz
// Packet Length Config: Variable
// Max Packet Length: 125
// Packet Length: 30
// RX Filter BW: 98 kHz
// Symbol Rate: 50.00000 kBaud
// Sync Word Length: 32 Bits
// TX Power: 14 dBm (requires define CCFG_FORCE_VDDR_HH = 1 in ccfg.c, see CC13xx/CC26xx Technical Reference Manual)
// Whitening: No whitening

void radioSetup_init() {
	// we copy from the template structures to the others, so we can modify them later
	int i;
	for (i=1; i<MAX_RADIO_SETUPS; i++) {
		radio_mode              [i] = radio_mode              [0];
		radio_cmd_prop_div_setup[i] = radio_cmd_prop_div_setup[0];
		radio_cmd_prop_tx       [i] = radio_cmd_prop_tx       [0];
		radio_cmd_prop_tx_adv   [i] = radio_cmd_prop_tx_adv   [0];
		radio_cmd_prop_rx       [i] = radio_cmd_prop_rx       [0];
		radio_cmd_fs            [i] = radio_cmd_fs            [0];
	}
}

//#define DEVIATION_STEP_SIZE  250

// documentation for the divider: Supported values: 2 (CC1350 only), 5, 6, 10, 12, 15, and 30

static const uint16_t bands_los[][2] = {
		{ 150, 30 }, // sivan experimental
		{ 315, 14 }, // not sure where the 14 is from, maybe 12 or 15 is better
		{ 433, 10 },
		{ 868,  5 },
		{ 915,  5 },
        { 1280,  3 }, // best value is probably between 3 and 4; may not work
        { 2440,  2 },
		{    0,  0 }
};

void radioSetup_frequency(uint32_t index, uint32_t f) {
	radio_cmd_fs[index].frequency = f / 1000000;
	radio_cmd_fs[index].fractFreq = (uint16_t) (((double) (f - 1000000*(radio_cmd_fs[index].frequency)) / 1e6) * 65535);

	System_printf("ind=%d f=%d full %d frac ==> %.6f\n",index,
			radio_cmd_fs[index].frequency,radio_cmd_fs[index].fractFreq,
			(double)(radio_cmd_fs[index].frequency)+(double)(radio_cmd_fs[index].fractFreq)/65535.0);

	if (true) { // Sivan Oct 2020 trying to get 2.4 working, was if (f < 1000000000) {
		int32_t mindiff  = -1;
		int     minindex = 0;
		int i;
		for (i=0; bands_los[i][0]; i++) {
			int32_t diff = f - bands_los[i][0]*1000000;
			if (diff < 0) diff = -diff;
			if (mindiff == -1 || diff < mindiff) {
				mindiff  = diff;
				minindex = i;
			}
		}
		System_printf("sub-1GHz f=%u band %d div %d\n",f,bands_los[minindex][0],bands_los[minindex][1]);
		radio_cmd_prop_div_setup[index].centerFreq = bands_los[minindex][0];
		radio_cmd_prop_div_setup[index].loDivider  = bands_los[minindex][1];
		//lo_divider[index] = radio_cmd_prop_div_setup[index].loDivider;

		loForSetup[index] = radio_cmd_prop_div_setup[index].loDivider;
	}

	// Sivan June 2022: for CC13X2 all the mode values are the same, 0.
	if (loForSetup[index] <= 2) {
        //System_printf("switching mode to prop 2.4\n");
	    radio_mode[index].rfMode = RF_MODE_PROPRIETARY_2_4;
	} else {
#ifdef DeviceFamily_CC13X0
        radio_mode[index].rfMode = RF_MODE_PROPRIETARY_SUB_1;
#endif
#ifdef DeviceFamily_CC13X2
        radio_mode[index].rfMode = RF_MODE_PROPRIETARY;
#endif
	}
}

static const uint16_t cc1310_rxbw[][2] = {
		{ 4240, 52 },
		{ 3470, 51 },
		{ 2800, 50 },
		{ 2120, 49 },
		{ 1740, 48 },
		{ 1410, 47 },
		{ 1060, 46 },
		{  870, 45 },
		{  700, 44 },
		{  530, 43 },
		{  430, 42 },
		{  350, 41 },
		{  260, 40 },
		{  220, 39 },
		{  180, 38 },
		{  130, 37 },
		{  110, 36 },
		{   88, 35 },
		{   66, 34 },
		{   55, 33 },
		{   45, 32 },
		{    0, 32 }
};

void radioSetup_modulation(uint32_t index, uint8_t modulation_type,
                              		uint32_t symbolrate,
		                              uint32_t deviation,
																	uint32_t rxbw) {

	radio_cmd_prop_div_setup[index].modulation.modType   = modulation_type;
	radio_cmd_prop_div_setup[index].modulation.deviation = deviation / DEVIATION_STEP_SIZE;

	System_printf("deviation %d = %d * 250 mod %d\n",deviation,radio_cmd_prop_div_setup[index].modulation.deviation,modulation_type);

	uint8_t  p;
	uint32_t r;

	p = 15;
	if (symbolrate >  50000) p = 6;
	if (symbolrate > 500000) p = 5;

	//for (p=15; p>=4; p--) {
	{
		r = (uint32_t) (((double) symbolrate * 1048576 * p) / 24e6);
		System_printf("symbolrate %d p=%d r=%d ==> %f\n",symbolrate,r,p, (24e6*r) / (1048576 * p));
		if (r < 2097152) {
			radio_cmd_prop_div_setup[index].symbolRate.preScale = p;
			radio_cmd_prop_div_setup[index].symbolRate.rateWord = r;
			//break;
		}
	}

	int i;
	for (i=0; rxbw <= 1000*cc1310_rxbw[i+1][0]; i++);
	System_printf("rxbw %d >= %d (%d)\n", rxbw, cc1310_rxbw[i][0], cc1310_rxbw[i][1]);
	radio_cmd_prop_div_setup[index].rxBw = cc1310_rxbw[i][1];

	// this needs to be overridden for LRM mode 2, where the number of preamble bytes specifies repetition of the sync word
	if (symbolrate > 50000) radio_cmd_prop_div_setup[index].preamConf.nPreamBytes = 8;
	else                    radio_cmd_prop_div_setup[index].preamConf.nPreamBytes = 5;
}


/********************************************************/
/* OVERRIDES                                            */
/********************************************************/

RF_Mode radio_mode[MAX_RADIO_SETUPS] = {
{
#ifdef CC1310
  .rfMode = RF_MODE_PROPRIETARY_SUB_1,
	.cpePatchFxn = &rf_patch_cpe_genfsk,
	.mcePatchFxn = 0,
	.rfePatchFxn = &rf_patch_rfe_genfsk,
#endif
#ifdef CC2650
	.rfMode = RF_MODE_PROPRIETARY,	// 0x3
	.cpePatchFxn = &applyPatch,
	.mcePatchFxn = &enterGenfskMcePatch,
	.rfePatchFxn = &enterGenfskRfePatch,
#endif
}};

#if 0
// Enhanced GFSK shape (reduced ISI) for 25 kHz deviation
uint32_t gfsk25kHzShape[] = {0x00000000, 0x00000000, 0x07040201, 0x281D140C, 0x4E473E33, 0x5A595754};

// Enhanced GFSK shape (reduced ISI) for 37.5 kHz deviation
uint32_t gfsk37_5kHzShape[] = {0x00000000, 0x01000000, 0x0B060301, 0x3B2B1D12, 0x74695B4B, 0x8483807B};

// Enhanced GFSK shape (reduced ISI) for 50 kHz deviation
uint32_t gfsk50kHzShape[] = {0x00000000, 0x01000000, 0x0E080402, 0x4E392718, 0x9A8C7A64, 0xB0AFABA4};

uint32_t cc2650_50kbps_pOverrides[] = {
		0x00001107, // Run patched MCE and RFE code from RAM
		0x00354038, // Synth: Set RTRIM (POTAILRESTRIM) to 5
		0x4001402D, // Synth: Correct CKVD latency setting (address)
		0x00608402, // Synth: Correct CKVD latency setting (value)
		0x4001405D, // Synth: Set ANADIV DIV_BIAS_MODE to PG1 (address)
		0x1801F800, // Synth: Set ANADIV DIV_BIAS_MODE to PG1 (value)
		0x000584A3, // Synth: Set FREF = 4.8 MHz (24 MHz / 5)
		0xC0040031, // Provide custom shape
		(uint32_t) gfsk50kHzShape, // Pointer to shape
		0xFFFFFFFF, // End of override list
};

/* Use for 250kbps */
uint32_t cc2650_250kbps_pOverrides[] = {
		0x00001107, // Run patched MCE and RFE code from RAM
		0x00354038, // Synth: Set RTRIM (POTAILRESTRIM) to 5
		0x4001402D, // Synth: Correct CKVD latency setting (address)
		0x00608402, // Synth: Correct CKVD latency setting (value)
		0x4001405D, // Synth: Set ANADIV DIV_BIAS_MODE to PG1 (address)
		0x1801F800, // Synth: Set ANADIV DIV_BIAS_MODE to PG1 (value)
		0x000584A3, // Synth: Set FREF = 4.8 MHz (24 MHz / 5)
//		0xC0040031, // Provide custom shape
//		(uint32_t) gfsk50kHzShape, // Pointer to shape
		0xFFFFFFFF, // End of override list
};


// Overrides for CMD_PROP_RADIO_DIV_SETUP
static uint32_t gfskOverrides[] = {
    // override_use_patch_prop_genfsk.xml
    // PHY: Use MCE ROM bank 4, RFE RAM patch
    MCE_RFE_OVERRIDE(0,4,0,1,0,0),
    // override_synth_prop_863_930_div5.xml
    // Synth: Set recommended RTRIM to 7
    HW_REG_OVERRIDE(0x4038,0x0037),
    // Synth: Set Fref to 4 MHz
    (uint32_t)0x000684A3,
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4020,0x7F00),
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4064,0x0040),
    // Synth: Configure fine calibration setting
    (uint32_t)0xB1070503,
    // Synth: Configure fine calibration setting
    (uint32_t)0x05330523,
    // Synth: Set loop bandwidth after lock to 20 kHz
    (uint32_t)0x0A480583,
    // Synth: Set loop bandwidth after lock to 20 kHz
    (uint32_t)0x7AB80603,
    // Synth: Configure VCO LDO (in ADI1, set VCOLDOCFG=0x9F to use voltage input reference)
    ADI_REG_OVERRIDE(1,4,0x9F),
    // Synth: Configure synth LDO (in ADI1, set SLDOCTL0.COMP_CAP=1)
    ADI_HALFREG_OVERRIDE(1,7,0x4,0x4),
    // Synth: Use 24 MHz XOSC as synth clock, enable extra PLL filtering
    (uint32_t)0x02010403,
    // Synth: Configure extra PLL filtering
    (uint32_t)0x00108463,
    // Synth: Increase synth programming timeout
    (uint32_t)0x04B00243,
    // override_phy_gfsk_rx.xml
    // Rx: Set LNA bias current trim offset to 3
    (uint32_t)0x00038883,
    // Rx: Freeze RSSI on sync found event
    HW_REG_OVERRIDE(0x6084,0x35F1),
    // override_phy_gfsk_pa_ramp_agc_reflevel_0x1a.xml
    // Tx: Enable PA ramping (0x41). Rx: Set AGC reference level to 0x1A.
    HW_REG_OVERRIDE(0x6088,0x411A),
    // Tx: Configure PA ramping setting
    HW_REG_OVERRIDE(0x608C,0x8213),
    // override_phy_rx_aaf_bw_0xd.xml
    // Rx: Set anti-aliasing filter bandwidth to 0xD (in ADI0, set IFAMPCTL3[7:4]=0xD)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0xD),
    // override_frontend_xd.xml
    // Rx: Set RSSI offset to adjust reported RSSI by +5 dB
    (uint32_t)0x00FB88A3,
    (uint32_t)0xFFFFFFFF,
};

static uint32_t lrmOverrides[] =
{
    // override_use_prop_lrm_rom.xml
    // PHY: Use MCE ROM bank 3, RFE ROM bank 4
    MCE_RFE_OVERRIDE(0,3,0,0,4,0),
    // override_synth_prop_863_930_div5.xml
    // Synth: Set recommended RTRIM to 7
    HW_REG_OVERRIDE(0x4038,0x0037),
    // Synth: Set Fref to 4 MHz
    (uint32_t)0x000684A3,
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4020,0x7F00),
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4064,0x0040),
    // Synth: Configure fine calibration setting
    (uint32_t)0xB1070503,
    // Synth: Configure fine calibration setting
    (uint32_t)0x05330523,
    // Synth: Set loop bandwidth after lock to 20 kHz
    (uint32_t)0x0A480583,
    // Synth: Set loop bandwidth after lock to 20 kHz
    (uint32_t)0x7AB80603,
    // Synth: Configure VCO LDO (in ADI1, set VCOLDOCFG=0x9F to use voltage input reference)
    ADI_REG_OVERRIDE(1,4,0x9F),
    // Synth: Configure synth LDO (in ADI1, set SLDOCTL0.COMP_CAP=1)
    ADI_HALFREG_OVERRIDE(1,7,0x4,0x4),
    // Synth: Use 24 MHz XOSC as synth clock, enable extra PLL filtering
    (uint32_t)0x02010403,
    // Synth: Configure extra PLL filtering
    (uint32_t)0x00108463,
    // Synth: Increase synth programming timeout
    (uint32_t)0x04B00243,
    // override_phy_gfsk_rx.xml
    // Rx: Set LNA bias current trim offset to 3
    (uint32_t)0x00038883,
    // Rx: Freeze RSSI on sync found event
    HW_REG_OVERRIDE(0x6084,0x35F1),
    // override_phy_gfsk_agc_reflevel_0x1a.xml
    // Rx: Set AGC reference level to 0x1A
    HW_REG_OVERRIDE(0x6088,0x001A),
    // override_phy_rx_aaf_bw_0xd.xml
    // Rx: Set anti-aliasing filter bandwidth to 0xD (in ADI0, set IFAMPCTL3[7:4]=0xD)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0xD),
    // override_phy_lrm_rom_dsss8.xml
    // PHY: Configure DSSS=8
    HW_REG_OVERRIDE(0x505C,0x073C),
    // override_frontend_xd.xml
    // Rx: Set RSSI offset to adjust reported RSSI by +5 dB
    (uint32_t)0x00FB88A3,
    // TX power override
    // Tx: Set PA trim to max (in ADI0, set PACTL0=0xF8)
    ADI_REG_OVERRIDE(0,12,0xF8),
    (uint32_t)0xFFFFFFFF,
};

#endif

#ifdef DeviceFamily_CC13X0

// Overrides for CMD_PROP_RADIO_DIV_SETUP
uint32_t overrides_fastlrm[] =
{
    MCE_RFE_OVERRIDE(1, 0, 0, 0, 4, 0), // MCE run from RAM, No RFE patch (PA ramping)
    HW32_ARRAY_OVERRIDE(0x6088,1),
    (uint32_t)0x0000001A,
    HW32_ARRAY_OVERRIDE(0x4038,1),
    (uint32_t)0x0000003A,
    HW_REG_OVERRIDE(0x4020,0x7F00),
    HW_REG_OVERRIDE(0x4064,0x0040),
    (uint32_t)0x684A3,   // Synth: Set FREF = 4 MHz (24 MHz / 6)
    (uint32_t)0xC0040141,
    (uint32_t)0x0533B107,
    (uint32_t)0x0A480583,
    (uint32_t)0x7AB80603,
    (uint32_t)0x02010403,
    (uint32_t)0x00108463,
    (uint32_t)0x04B00243,
    ADI_REG_OVERRIDE(1,4,0x9F),
    ADI_HALFREG_OVERRIDE(1,7,0x4,0x4),
    HW_REG_OVERRIDE(0x6084,0x35F1),
    (uint32_t)0x00038883,
    (uint32_t)0x00FB88A3,
    HW_REG_OVERRIDE(0x6088,0x1F0E), // AGC reference level
    // TX power override
    ADI_REG_OVERRIDE(0,12,0xF9),
    // Overrides for LRM
    HW_REG_OVERRIDE(0x52AC,0x0F33), //DSSS = 8, K=4
    //HW_REG_OVERRIDE(0x52AC,0x0B03), //DSSS = 4, K=4
    //HW_REG_OVERRIDE(0x52AC,0x0900), //DSSS = 2, K=4
    //HW_REG_OVERRIDE(0x52AC,0x0800), //DSSS = 1, K=4
    HW_REG_OVERRIDE(0x5108,0x0048), //Correlator Threshold for Sync
    (uint32_t)0xFFFFFFFF,
};

// Sivan Sep 2019 from SmartRF Studio
uint32_t overrides_434[] =
{
    // override_use_patch_prop_genfsk.xml
    // PHY: Use MCE ROM bank 4, RFE RAM patch
    MCE_RFE_OVERRIDE(0,4,0,1,0,0),
    // override_synth_prop_430_510_div10.xml
    // Synth: Set recommended RTRIM to 7
    HW_REG_OVERRIDE(0x4038,0x0037),
    // Synth: Set Fref to 4 MHz
    (uint32_t)0x000684A3,
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4020,0x7F00),
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4064,0x0040),
    // Synth: Configure fine calibration setting
    (uint32_t)0xB1070503,
    // Synth: Configure fine calibration setting
    (uint32_t)0x05330523,
    // Synth: Set loop bandwidth after lock to 20 kHz
    (uint32_t)0x0A480583,
    // Synth: Set loop bandwidth after lock to 20 kHz
    (uint32_t)0x7AB80603,
    // Synth: Configure VCO LDO (in ADI1, set VCOLDOCFG=0x9F to use voltage input reference)
    ADI_REG_OVERRIDE(1,4,0x9F),
    // Synth: Configure synth LDO (in ADI1, set SLDOCTL0.COMP_CAP=1)
    ADI_HALFREG_OVERRIDE(1,7,0x4,0x4),
    // Synth: Use 24 MHz XOSC as synth clock, enable extra PLL filtering
    (uint32_t)0x02010403,
    // Synth: Configure extra PLL filtering
    (uint32_t)0x00108463,
    // Synth: Increase synth programming timeout (0x04B0 RAT ticks = 300 us)
    (uint32_t)0x04B00243,
    // override_synth_disable_bias_div10.xml
    // Synth: Set divider bias to disabled
    HW32_ARRAY_OVERRIDE(0x405C,1),
    // Synth: Set divider bias to disabled (specific for loDivider=10)
    (uint32_t)0x18000280,
    // override_phy_rx_aaf_bw_0xd.xml
    // Rx: Set anti-aliasing filter bandwidth to 0xD (in ADI0, set IFAMPCTL3[7:4]=0xD)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0xD),
    // override_phy_gfsk_rx.xml
    // Rx: Set LNA bias current trim offset to 3
    (uint32_t)0x00038883,
    // Rx: Freeze RSSI on sync found event
    HW_REG_OVERRIDE(0x6084,0x35F1),
    // override_phy_gfsk_pa_ramp_agc_reflevel_0x1a.xml
    // Tx: Configure PA ramping setting (0x41). Rx: Set AGC reference level to 0x1A.
    HW_REG_OVERRIDE(0x6088,0x411A),
    // Tx: Configure PA ramping setting
    HW_REG_OVERRIDE(0x608C,0x8213),
    // override_phy_rx_rssi_offset_neg2db.xml
    // Rx: Set RSSI offset to adjust reported RSSI by -2 dB (default: 0), trimmed for external bias and differential configuration
    (uint32_t)0x000288A3,
    (uint32_t)0xFFFFFFFF
};

// from Smart RF Studio, August 2020, for 915 (did not work with newOverrdes on 915)
// verified June 2022
// add HW_REG_OVERRIDE(0x505C,0x0100), for mode 2
uint32_t overrides_915[] =
{
    // override_use_patch_prop_genfsk.xml
    // PHY: Use MCE ROM bank 4, RFE RAM patch
    MCE_RFE_OVERRIDE(0,4,0,1,0,0),               // MCE_RFE_OVERRIDE(1,0,0,1,0,0), for mode 2
    // override_synth_prop_863_930_div5.xml
    // Synth: Set recommended RTRIM to 7
    HW_REG_OVERRIDE(0x4038,0x0037),
    // Synth: Set Fref to 4 MHz
    (uint32_t)0x000684A3,                        // 0x000784A3 3.43MHz in 2.4 BLE
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4020,0x7F00),
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4064,0x0040),
    // Synth: Configure fine calibration setting
    (uint32_t)0xB1070503,
    // Synth: Configure fine calibration setting
    (uint32_t)0x05330523,
    // 80 kHz for BLE: 0xA47E0583, 0xA47E0583, 0xEAE00603
    // 60 kHz for mode 2: 0x40410583, 0x32CC0603, 0x00010623
    // Synth: Set loop bandwidth after lock to 20 kHz
    (uint32_t)0x0A480583,
    // Synth: Set loop bandwidth after lock to 20 kHz
    (uint32_t)0x7AB80603,
    // Synth: Configure VCO LDO (in ADI1, set VCOLDOCFG=0x9F to use voltage input reference)
    ADI_REG_OVERRIDE(1,4,0x9F),
    // Synth: Configure synth LDO (in ADI1, set SLDOCTL0.COMP_CAP=1)
    ADI_HALFREG_OVERRIDE(1,7,0x4,0x4),
    // Synth: Use 24 MHz XOSC as synth clock, enable extra PLL filtering
    (uint32_t)0x02010403,
    // Synth: Configure extra PLL filtering
    (uint32_t)0x00108463,
    // Synth: Increase synth programming timeout (0x04B0 RAT ticks = 300 us)
    (uint32_t)0x04B00243,
    // override_synth_disable_bias_div5.xml
    // Synth: Set divider bias to disabled
    HW32_ARRAY_OVERRIDE(0x405C,1),
    // Synth: Set divider bias to disabled (specific for loDivider=5)
    (uint32_t)0x18000200,                                      // 0x18000280, for loDiv=10, 0x18000000 for 2.4GHz
    // override_phy_rx_aaf_bw_0x0.xml
    // Rx: Set anti-aliasing filter bandwidth to 0x0 (in ADI0, set IFAMPCTL3[7:4]=0x0)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0x0),                     // ADI_HALFREG_OVERRIDE(0,61,0xF,0xD) for mode 2, 5kb/s
    // override_phy_gfsk_rx.xml
    // Rx: Set LNA bias current trim offset to 3
    (uint32_t)0x00038883,
    // Rx: Freeze RSSI on sync found event
    HW_REG_OVERRIDE(0x6084,0x35F1),
    // override_phy_gfsk_pa_ramp_5us_agc_reflevel_0x24.xml
    // Tx: Configure PA ramping setting (0x10) for approximately 5 us PA ramp time. Rx: Set AGC reference level to 0x24.
    HW_REG_OVERRIDE(0x6088,0x1024),                            // 0x4114 for mode 2, 5kb/s, 0x4116 or 411A for 434MHz, 0x0045 for BLE
    // Tx: Configure PA ramping setting (0x08) for approximately 5 us PA ramp time
    HW_REG_OVERRIDE(0x608C,0x0813),                            // ,0x8213 for mode 2, 05FD for BLE
    // override_phy_rx_rssi_offset_5db.xml
    // Rx: Set RSSI offset to adjust reported RSSI by +5 dB (default: 0), trimmed for external bias and differential configuration
    (uint32_t)0x00FB88A3,
    // TX power override
    // Tx: Set PA trim to max (in ADI0, set PACTL0=0xF8)
    ADI_REG_OVERRIDE(0,12,0xF8),
    (uint32_t)0xFFFFFFFF
};

// Sivan June 2022 modified from 915
uint32_t overrides_2400[] =
{
    // override_use_patch_prop_genfsk.xml
    // PHY: Use MCE ROM bank 4, RFE RAM patch
    MCE_RFE_OVERRIDE(0,4,0,1,0,0),               // MCE_RFE_OVERRIDE(1,0,0,1,0,0), for mode 2
    // override_synth_prop_863_930_div5.xml
    // Synth: Set recommended RTRIM to 7
    HW_REG_OVERRIDE(0x4038,0x0037),
    // Synth: Set Fref to 4 MHz
    (uint32_t)0x000684A3,                        // 0x000784A3 3.43MHz in 2.4 BLE
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4020,0x7F00),
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4064,0x0040),
    // Synth: Configure fine calibration setting
    (uint32_t)0xB1070503,
    // Synth: Configure fine calibration setting
    (uint32_t)0x05330523,
    // 80 kHz for BLE: 0xA47E0583, 0xA47E0583, 0xEAE00603
    // 60 kHz for mode 2: 0x40410583, 0x32CC0603, 0x00010623
    // Synth: Set loop bandwidth after lock to 20 kHz
    (uint32_t)0x0A480583,
    // Synth: Set loop bandwidth after lock to 20 kHz
    (uint32_t)0x7AB80603,
    // Synth: Configure VCO LDO (in ADI1, set VCOLDOCFG=0x9F to use voltage input reference)
    ADI_REG_OVERRIDE(1,4,0x9F),
    // Synth: Configure synth LDO (in ADI1, set SLDOCTL0.COMP_CAP=1)
    ADI_HALFREG_OVERRIDE(1,7,0x4,0x4),
    // Synth: Use 24 MHz XOSC as synth clock, enable extra PLL filtering
    (uint32_t)0x02010403,
    // Synth: Configure extra PLL filtering
    (uint32_t)0x00108463,
    // Synth: Increase synth programming timeout (0x04B0 RAT ticks = 300 us)
    (uint32_t)0x04B00243,
    // override_synth_disable_bias_div5.xml
    // Synth: Set divider bias to disabled
    HW32_ARRAY_OVERRIDE(0x405C,1),
    // Synth: Set divider bias to disabled (specific for loDivider=5)
    (uint32_t)0x18000000,                                      // 0x18000280, for loDiv=10, 0x18000000 for 2.4GHz
    // override_phy_rx_aaf_bw_0x0.xml
    // Rx: Set anti-aliasing filter bandwidth to 0x0 (in ADI0, set IFAMPCTL3[7:4]=0x0)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0x0),                     // ADI_HALFREG_OVERRIDE(0,61,0xF,0xD) for mode 2, 5kb/s
    //ADI_HALFREG_OVERRIDE(0,61,0xF,0x5),             // Sivan June 2022        // ADI_HALFREG_OVERRIDE(0,61,0xF,0xD) for mode 2, 5kb/s
    // override_phy_gfsk_rx.xml
    // Rx: Set LNA bias current trim offset to 3
    (uint32_t)0x00038883,
    // Rx: Freeze RSSI on sync found event
    HW_REG_OVERRIDE(0x6084,0x35F1),
    // override_phy_gfsk_pa_ramp_5us_agc_reflevel_0x24.xml
    // Tx: Configure PA ramping setting (0x10) for approximately 5 us PA ramp time. Rx: Set AGC reference level to 0x24.
    HW_REG_OVERRIDE(0x6088,0x1024),                            // 0x4114 for mode 2, 5kb/s, 0x4116 or 411A for 434MHz, 0x0045 for BLE
    // Tx: Configure PA ramping setting (0x08) for approximately 5 us PA ramp time
    HW_REG_OVERRIDE(0x608C,0x0813),                            // ,0x8213 for mode 2, 05FD for BLE
    // override_phy_rx_rssi_offset_5db.xml
    // Rx: Set RSSI offset to adjust reported RSSI by +5 dB (default: 0), trimmed for external bias and differential configuration
    (uint32_t)0x00FB88A3,
    // TX power override
    // Tx: Set PA trim to max (in ADI0, set PACTL0=0xF8)
    ADI_REG_OVERRIDE(0,12,0xF8),
    (uint32_t)0xFFFFFFFF
};


uint32_t overrides_mode2[] =
{
    // override_use_patch_simplelink_long_range.xml
    // PHY: Use MCE RAM patch, RFE RAM patch
    MCE_RFE_OVERRIDE(1,0,0,1,0,0),
    // override_synth_prop_430_510_div10_lbw60k.xml
    // Synth: Set recommended RTRIM to 7
    HW_REG_OVERRIDE(0x4038,0x0037),
    // Synth: Set Fref to 4 MHz
    (uint32_t)0x000684A3,
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4020,0x7F00),
    // Synth: Configure fine calibration setting
    HW_REG_OVERRIDE(0x4064,0x0040),
    // Synth: Configure fine calibration setting
    (uint32_t)0xB1070503,
    // Synth: Configure fine calibration setting
    (uint32_t)0x05330523,
    // Synth: Set loop bandwidth after lock to 60 kHz
    (uint32_t)0x40410583,
    // Synth: Set loop bandwidth after lock to 60 kHz
    (uint32_t)0x32CC0603,
    // Synth: Set loop bandwidth after lock to 60 kHz
    (uint32_t)0x00010623,
    // Synth: Configure VCO LDO (in ADI1, set VCOLDOCFG=0x9F to use voltage input reference)
    ADI_REG_OVERRIDE(1,4,0x9F),
    // Synth: Configure synth LDO (in ADI1, set SLDOCTL0.COMP_CAP=1)
    ADI_HALFREG_OVERRIDE(1,7,0x4,0x4),
    // Synth: Use 24 MHz XOSC as synth clock, enable extra PLL filtering
    (uint32_t)0x02010403,
    // Synth: Configure extra PLL filtering
    (uint32_t)0x00108463,
    // Synth: Increase synth programming timeout (0x04B0 RAT ticks = 300 us)
    (uint32_t)0x04B00243,
    // override_synth_disable_bias_div10.xml
    // Synth: Set divider bias to disabled
    HW32_ARRAY_OVERRIDE(0x405C,1),
    // Synth: Set divider bias to disabled (specific for loDivider=10)
    (uint32_t)0x18000280,
    // override_phy_rx_aaf_bw_0xd.xml
    // Rx: Set anti-aliasing filter bandwidth to 0xD (in ADI0, set IFAMPCTL3[7:4]=0xD)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0xD),
    // override_phy_gfsk_rx.xml
    // Rx: Set LNA bias current trim offset to 3
    (uint32_t)0x00038883,
    // Rx: Freeze RSSI on sync found event
    HW_REG_OVERRIDE(0x6084,0x35F1),
    // override_phy_gfsk_pa_ramp_agc_reflevel_0x16.xml
    // Tx: Configure PA ramping setting (0x41). Rx: Set AGC reference level to 0x16.
    HW_REG_OVERRIDE(0x6088,0x4116),
    // Tx: Configure PA ramping setting
    HW_REG_OVERRIDE(0x608C,0x8213),
    // override_phy_long_range_dsss2.xml
    // PHY: Configure DSSS SF=2
    HW_REG_OVERRIDE(0x505C,0x0100), // for DSSS=2 use 0x0100, DSSS=4 use 0x0303, for DSSS=8 use 0x073C; DSSS=1 is not supported in mode 2
    //HW_REG_OVERRIDE(0x505C,0x0303), // for DSSS=2 use 0x0100, DSSS=4 use 0x0303, for DSSS=8 use 0x073C; DSSS=1 is not supported in mode 2
    // override_phy_rx_rssi_offset_neg2db.xml
    // Rx: Set RSSI offset to adjust reported RSSI by -2 dB (default: 0), trimmed for external bias and differential configuration
    (uint32_t)0x000288A3,
    (uint32_t)0xFFFFFFFF
};

#endif

#ifdef DeviceFamily_CC13X2
uint32_t overrides_fastlrm[] = {(uint32_t)0xFFFFFFFF}; // missing
uint32_t overrides_434[] =
{
    // override_tc148.xml
    // Tx: Configure PA ramp time, PACTL2.RC=0x3 (in ADI0, set PACTL2[4:3]=0x3)
    ADI_2HALFREG_OVERRIDE(0,16,0x8,0x8,17,0x1,0x1),
    // Rx: Set AGC reference level to 0x16 (default: 0x2E)
    HW_REG_OVERRIDE(0x609C,0x0016),
    // Rx: Set RSSI offset to adjust reported RSSI by -7 dB (default: -2), trimmed for external bias and differential configuration
    (uint32_t)0x000788A3,
    // Rx: Set anti-aliasing filter bandwidth to 0x8 (in ADI0, set IFAMPCTL3[7:4]=0x8)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0x8),
    // override_prop_common.xml
    // DC/DC regulator: In Tx with 14 dBm PA setting, use DCDCCTL5[3:0]=0xF (DITHER_EN=1 and IPEAK=7). In Rx, use default settings.
    (uint32_t)0x00F788D3,
    // override_prop_common_sub1g.xml
    // Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
    (uint32_t)0x4001405D,
    // Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
    (uint32_t)0x08141131,
    // override_phy_tx_pa_ramp_genfsk_std.xml
    // Tx: Configure PA ramping, set wait time before turning off (0x1A ticks of 16/24 us = 17.3 us).
    HW_REG_OVERRIDE(0x6028,0x001A),
    // Set TXRX pin to 0 in RX and high impedance in idle/TX.
    HW_REG_OVERRIDE(0x60A8,0x0401),
    (uint32_t)0xFFFFFFFF
};

// 200kb/s settings
uint32_t overrides_2400[] =
{
    // override_tc901.xml
    // DC/DC regulator: In Tx, use DCDCCTL5[3:0]=0x3 (DITHER_EN=0 and IPEAK=3).
    (uint32_t)0x00F388D3,
    // Tx: Configure PA ramp time, PACTL2.RC=0x1 (in ADI0, set PACTL2[4:3]=0x1)
    ADI_2HALFREG_OVERRIDE(0,16,0x8,0x8,17,0x1,0x0),
    // Rx: Set AGC reference level to 0x22 (default: 0x2E)
    HW_REG_OVERRIDE(0x609C,0x0022),  // ; 20 for 100kbs
    // Rx: Set anti-aliasing filter bandwidth to 0x5 (in ADI0, set IFAMPCTL3[7:4]=0x5)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0x4), // was 5 for 200kb/s; 9 for 100kb/s
    // override_hposc.xml
    // HPOSC frequency offset override, freqOffset=2^22*(F_nom-F_hposc)/F_hposc
    HPOSC_OVERRIDE(0),
    (uint32_t)0xFFFFFFFF
};

// 200kb/s settings
uint32_t overrides_2400_mode2_sf4[] =
{
    // override_tc901.xml
    // DC/DC regulator: In Tx, use DCDCCTL5[3:0]=0x3 (DITHER_EN=0 and IPEAK=3).
    (uint32_t)0x00F388D3,
    // Tx: Configure PA ramp time, PACTL2.RC=0x2 (in ADI0, set PACTL2[4:3]=0x2)
    ADI_2HALFREG_OVERRIDE(0,16,0x8,0x0,17,0x1,0x1),
    // Rx: Set AGC reference level to 0x22 (default: 0x2E)
    HW_REG_OVERRIDE(0x609C,0x0020),  // ; 20 for 100kbs
    // Rx: Set anti-aliasing filter bandwidth to 0x5 (in ADI0, set IFAMPCTL3[7:4]=0x5)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0x9), // was 5 for 200kb/s; 9 for 100kb/s
    // override_hposc.xml
    // HPOSC frequency offset override, freqOffset=2^22*(F_nom-F_hposc)/F_hposc
    HW_REG_OVERRIDE(0x5068,0x030C), // SF4
    HPOSC_OVERRIDE(0),
    (uint32_t)0xFFFFFFFF
};


// 100kbs
uint32_t overrides_2400_100kbs[] =
{
    // override_tc900.xml
    // DC/DC regulator: In Tx, use DCDCCTL5[3:0]=0x3 (DITHER_EN=0 and IPEAK=3).
    (uint32_t)0x00F388D3,
    // Tx: Configure PA ramp time, PACTL2.RC=0x2 (in ADI0, set PACTL2[4:3]=0x2)
    ADI_2HALFREG_OVERRIDE(0,16,0x8,0x0,17,0x1,0x1),
    // Rx: Set AGC reference level to 0x20 (default: 0x2E)
    HW_REG_OVERRIDE(0x609C,0x0020),
    // Rx: Set anti-aliasing filter bandwidth to 0x9 (in ADI0, set IFAMPCTL3[7:4]=0x9)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0x9),
    // override_hposc.xml
    // HPOSC frequency offset override, freqOffset=2^22*(F_nom-F_hposc)/F_hposc
    HPOSC_OVERRIDE(0),
    (uint32_t)0xFFFFFFFF
};


// June 2022 915MHz 1mb/s
uint32_t overrides_915[] =
{
    // override_tc784_tc785.xml
    // Tx: Configure PA ramp time, PACTL2.RC=0x3 (in ADI0, set PACTL2[4:3]=0x3)
    ADI_2HALFREG_OVERRIDE(0,16,0x8,0x8,17,0x1,0x1),
    // Rx: Set AGC reference level to 0x2E (default: 0x2E)
    HW_REG_OVERRIDE(0x609C,0x002E),
    // Rx: Set RSSI offset to adjust reported RSSI by -4 dB (default: -2), trimmed for external bias and differential configuration
    (uint32_t)0x000488A3,
    // Rx: Set LNA Ib boost
    ADI_HALFREG_OVERRIDE(0,5,0xF,0x2),
    // Rx: Set anti-aliasing filter bandwidth to 0x0 (in ADI0, set IFAMPCTL3[7:4]=0xD)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0x0),
    // TX: Reduce analog ramping wait time
    HW_REG_OVERRIDE(0x6028,0x001A),
    // TX: set intFreq = 0
    (uint32_t)0x00000343,
    // override_prop_common.xml
    // DC/DC regulator: In Tx with 14 dBm PA setting, use DCDCCTL5[3:0]=0xF (DITHER_EN=1 and IPEAK=7). In Rx, use default settings.
    (uint32_t)0x00F788D3,
    // override_prop_common_sub1g.xml
    // Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
    (uint32_t)0x4001405D,
    // Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
    (uint32_t)0x08141131,
    (uint32_t)0xFFFFFFFF
};

uint32_t overrides_915_1mbs_pa[] =
{
    // override_tc784_tc785.xml
    // Tx: Configure PA ramp time, PACTL2.RC=0x3 (in ADI0, set PACTL2[4:3]=0x3)
    ADI_2HALFREG_OVERRIDE(0,16,0x8,0x8,17,0x1,0x1),
    // Rx: Set AGC reference level to 0x2E (default: 0x2E)
    HW_REG_OVERRIDE(0x609C,0x002E),
    // Rx: Set RSSI offset to adjust reported RSSI by -4 dB (default: -2), trimmed for external bias and differential configuration
    (uint32_t)0x000488A3,
    // Rx: Set LNA Ib boost
    ADI_HALFREG_OVERRIDE(0,5,0xF,0x2),
    // Rx: Set anti-aliasing filter bandwidth to 0x0 (in ADI0, set IFAMPCTL3[7:4]=0xD)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0x0),
    // TX: Reduce analog ramping wait time
    HW_REG_OVERRIDE(0x6028,0x001A),
    // TX: set intFreq = 0
    (uint32_t)0x00000343,
    // override_prop_common.xml
    // DC/DC regulator: In Tx with 14 dBm PA setting, use DCDCCTL5[3:0]=0xF (DITHER_EN=1 and IPEAK=7). In Rx, use default settings.
    (uint32_t)0x00F788D3,
    // override_prop_common_sub1g.xml
    // Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
    (uint32_t)0x4001405D,
    // Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
    (uint32_t)0x08141131,
    (uint32_t)0xFFFFFFFF
};

// Overrides for CMD_PROP_RADIO_DIV_SETUP_PA
// up to date for 915 July 2022
uint32_t overrides_txstd_915[] =
{
    // The TX Power element should always be the first in the list
    TX_STD_POWER_OVERRIDE(0x013F),
    // The ANADIV radio parameter based on the LO divider (0) and front-end (0) settings
    (uint32_t)0x11310703,
    // override_phy_tx_pa_ramp_genfsk_std.xml
    // Tx: Configure PA ramping, set wait time before turning off (0x1A ticks of 16/24 us = 17.3 us).
    HW_REG_OVERRIDE(0x6028,0x001A),
    // Set TXRX pin to 0 in RX and high impedance in idle/TX.
    HW_REG_OVERRIDE(0x60A8,0x0401),
    (uint32_t)0xFFFFFFFF
};


// Overrides for CMD_PROP_RADIO_DIV_SETUP_PA
uint32_t overrides_tx20_915[] =
{
    // The TX Power element should always be the first in the list
    TX20_POWER_OVERRIDE(0x001B8ED2),
    // The ANADIV radio parameter based on the LO divider (0) and front-end (0) settings
    (uint32_t)0x11C10703,
    // override_phy_tx_pa_ramp_genfsk_hpa.xml
    // Tx: Configure PA ramping, set wait time before turning off (0x1F ticks of 16/24 us = 20.3 us).
    HW_REG_OVERRIDE(0x6028,0x001F),
    // Set TXRX pin to 0 in RX/TX and high impedance in idle.
    HW_REG_OVERRIDE(0x60A8,0x0001),
    (uint32_t)0xFFFFFFFF
};

uint32_t overrides_mode2[] =
{
  // override_tc901.xml
  // DC/DC regulator: In Tx, use DCDCCTL5[3:0]=0x3 (DITHER_EN=0 and IPEAK=3).
  (uint32_t)0x00F388D3,
  // Tx: Configure PA ramp time, PACTL2.RC=0x1 (in ADI0, set PACTL2[4:3]=0x1)
  ADI_2HALFREG_OVERRIDE(0,16,0x8,0x8,17,0x1,0x0),
  //ADI_2HALFREG_OVERRIDE(0,16,0x8,0x8,17,0x1,0x1),
  // Rx: Set AGC reference level to 0x22 (default: 0x2E)
  HW_REG_OVERRIDE(0x609C,0x0022),  // ; 20 for 100kbs
  //HW_REG_OVERRIDE(0x609C,0x0017), // 19 for 434
  // Rx: Set anti-aliasing filter bandwidth to 0x5 (in ADI0, set IFAMPCTL3[7:4]=0x5)
  ADI_HALFREG_OVERRIDE(0,61,0xF,0x5), // was 5 for 200kb/s; 9 for 100kb/s
  //ADI_HALFREG_OVERRIDE(0,61,0xF,0xD),
  // override_hposc.xml
  // HPOSC frequency offset override, freqOffset=2^22*(F_nom-F_hposc)/F_hposc
  // override_phy_simplelink_long_range_dsss2.xml
  // PHY: Configure DSSS SF=2 for payload data
  HW_REG_OVERRIDE(0x5068,0x0100),
  // Rx: Set RSSI offset to adjust reported RSSI by -2 dB (default: -2), trimmed for external bias and differential configuration
  (uint32_t)0x000288A3,
  // Rx: Set anti-aliasing filter bandwidth to 0xD (in ADI0, set IFAMPCTL3[7:4]=0xD)
  HPOSC_OVERRIDE(0),
  (uint32_t)0xFFFFFFFF
};

uint32_t overrides_mode2_sub[] =
{
    // override_phy_simplelink_long_range_dsss2.xml
    // PHY: Configure DSSS SF=2 for payload data
    HW_REG_OVERRIDE(0x5068,0x0100),
    // override_prop_common_sub1g.xml
    // Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
    (uint32_t)0x4001405D,
    // Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
    (uint32_t)0x08141131,
    // override_tc880_tc881_tc882.xml
    // Tx: Configure PA ramp time, PACTL2.RC=0x3 (in ADI0, set PACTL2[4:3]=0x3)
    ADI_2HALFREG_OVERRIDE(0,16,0x8,0x8,17,0x1,0x1),
    // Rx: Set AGC reference level to 0x17 (default: 0x2E)
    HW_REG_OVERRIDE(0x609C,0x0017), // 19 for 434
    // Rx: Set RSSI offset to adjust reported RSSI by -2 dB (default: -2), trimmed for external bias and differential configuration
    (uint32_t)0x000288A3,
    // Rx: Set anti-aliasing filter bandwidth to 0xD (in ADI0, set IFAMPCTL3[7:4]=0xD)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0xD),
    // override_prop_common.xml
    // DC/DC regulator: In Tx with 14 dBm PA setting, use DCDCCTL5[3:0]=0xF (DITHER_EN=1 and IPEAK=7). In Rx, use default settings.
    (uint32_t)0x00F788D3,
    (uint32_t)0xFFFFFFFF
};



uint32_t overrides_txstd_2400[] =
{
    // The TX Power element should always be the first in the list
    TX_STD_POWER_OVERRIDE(0x7217),
    // The ANADIV radio parameter based on the LO divider (0) and front-end (0) settings
    (uint32_t)0x05320703,
    // override_txstd_settings.xml
    // Bluetooth 5: Set RTIM offset to default for standard PA
    (uint32_t)0x00008783,
    // Bluetooth 5: Set synth mux to default value for standard PA
    (uint32_t)0x050206C3,
    // Set TXRX pin to 0 in RX and high impedance in idle/TX.
    HW_REG_OVERRIDE(0x60A8,0x0401),
    // Bluetooth 5: Set DTX gain -5% for 1 Mbps
    //(uint32_t)0x00E787E3,
    // Bluetooth 5: Set DTX gain -2.5% for 2 Mbps
    //(uint32_t)0x00F487F3,
    // Bluetooth 5: Set enhanced TX shape
    //(uint32_t)0x000D8C73,
    (uint32_t)0xFFFFFFFF
};

uint32_t overrides_tx20_2400[] =
{
    // The TX Power element should always be the first in the list
   TX20_POWER_OVERRIDE(0x003F75F5),
    // The ANADIV radio parameter based on the LO divider (0) and front-end (0) settings
    (uint32_t)0x01C20703,
    // override_tx20_settings.xml
    // Bluetooth 5: Set RTIM offset to 3 for high power PA
    (uint32_t)0x00030783,
    // Bluetooth 5: Set synth mux for high power PA
    (uint32_t)0x010206C3,
    // Set TXRX pin to 0 in RX/TX and high impedance in idle.
    HW_REG_OVERRIDE(0x60A8,0x0001),
    // Bluetooth 5: Turn off DTX gain adjustment
    //(uint32_t)0x000007E3,
    // Bluetooth 5: Set default TX shape
    //(uint32_t)0x00008C73,
    (uint32_t)0xFFFFFFFF
};

uint32_t overrides_434_100kbs_mode2[] =
{
    // override_phy_simplelink_long_range_dsss2.xml
    // PHY: Configure DSSS SF=2 for payload data
    HW_REG_OVERRIDE(0x5068,0x0100),
    // override_tc440_tc441.xml
    // Tx: Configure PA ramp time, PACTL2.RC=0x3 (in ADI0, set PACTL2[4:3]=0x3)
    ADI_2HALFREG_OVERRIDE(0,16,0x8,0x8,17,0x1,0x1),
    // Rx: Set AGC reference level to 0x19 (default: 0x2E)
    HW_REG_OVERRIDE(0x609C,0x0019),
    // Rx: Set RSSI offset to adjust reported RSSI by -7 dB (default: -2), trimmed for external bias and differential configuration
    (uint32_t)0x000788A3,
    // Rx: Set anti-aliasing filter bandwidth to 0xD (in ADI0, set IFAMPCTL3[7:4]=0xD)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0xD),
    // override_prop_common.xml
    // DC/DC regulator: In Tx with 14 dBm PA setting, use DCDCCTL5[3:0]=0xF (DITHER_EN=1 and IPEAK=7). In Rx, use default settings.
    (uint32_t)0x00F788D3,
    // override_prop_common_sub1g.xml
    // Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
    (uint32_t)0x4001405D,
    // Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
    (uint32_t)0x08141131,
    // override_phy_tx_pa_ramp_genfsk_std.xml
    // Tx: Configure PA ramping, set wait time before turning off (0x1A ticks of 16/24 us = 17.3 us).
    HW_REG_OVERRIDE(0x6028,0x001A),
    // Set TXRX pin to 0 in RX and high impedance in idle/TX.
    HW_REG_OVERRIDE(0x60A8,0x0401),
    (uint32_t)0xFFFFFFFF
};




uint32_t overrides_915_old[] =
{
    // override_tc784_tc785.xml
    // Tx: Configure PA ramp time, PACTL2.RC=0x3 (in ADI0, set PACTL2[4:3]=0x3)
    ADI_2HALFREG_OVERRIDE(0,16,0x8,0x8,17,0x1,0x1),
    // Rx: Set AGC reference level to 0x2E (default: 0x2E)
    HW_REG_OVERRIDE(0x609C,0x002E),
    // Rx: Set RSSI offset to adjust reported RSSI by -4 dB (default: -2), trimmed for external bias and differential configuration
    (uint32_t)0x000488A3,
    // Set LNA IB offset factor to 0xF
    (uint32_t)0x000F8883,
    // Rx: Set anti-aliasing filter bandwidth to 0x0 (in ADI0, set IFAMPCTL3[7:4]=0xD)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0x0),
    // TX: Reduce analog ramping wait time
    HW_REG_OVERRIDE(0x6028,0x001A),
    // override_prop_common.xml
    // DC/DC regulator: In Tx with 14 dBm PA setting, use DCDCCTL5[3:0]=0xF (DITHER_EN=1 and IPEAK=7). In Rx, use default settings.
    (uint32_t)0x00F788D3,
    // override_prop_common_sub1g.xml
    // Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
    (uint32_t)0x4001405D,
    // Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
    (uint32_t)0x08141131,
    (uint32_t)0xFFFFFFFF
};

// looks like these came from Vegard_H on e2e as advice for 434MHz
uint32_t overrides_CC1352P_915_PA[] = // old
{
// override_tc784_tc785.xml
// Tx: Configure PA ramp time, PACTL2.RC=0x3 (in ADI0, set PACTL2[4:3]=0x3)
ADI_2HALFREG_OVERRIDE(0,16,0x8,0x8,17,0x1,0x1),
// Rx: Set AGC reference level to 0x20 (default: 0x2E)
HW_REG_OVERRIDE(0x609C,0x0020),
// Rx: Set RSSI offset to adjust reported RSSI by -8 dB (default: -2), trimmed for external bias and differential configuration
(uint32_t)0x000888A3,
// Set LNA IB offset factor to 0xF
(uint32_t)0x000F8883,
// Rx: Set anti-aliasing filter bandwidth to 0xD (in ADI0, set IFAMPCTL3[7:4]=0xD)
ADI_HALFREG_OVERRIDE(0,61,0xF,0xD),
// TX: Reduce analog ramping wait time
HW_REG_OVERRIDE(0x6028,0x001A),
// override_prop_common.xml
// DC/DC regulator: In Tx with 14 dBm PA setting, use DCDCCTL5[3:0]=0xF (DITHER_EN=1 and IPEAK=7). In Rx, use default settings.
(uint32_t)0x00F788D3,
// override_prop_common_sub1g.xml
// Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
(uint32_t)0x4001405D,
// Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
(uint32_t)0x08141131,
(uint32_t)0xFFFFFFFF
};

uint32_t overrides_CC1352P_915_PA_915[] =
{
    // override_tc784_tc785.xml
    // Tx: Configure PA ramp time, PACTL2.RC=0x3 (in ADI0, set PACTL2[4:3]=0x3)
    ADI_2HALFREG_OVERRIDE(0,16,0x8,0x8,17,0x1,0x1),
    // Rx: Set AGC reference level to 0x2E (default: 0x2E)
    HW_REG_OVERRIDE(0x609C,0x002E),
    // Rx: Set RSSI offset to adjust reported RSSI by -4 dB (default: -2), trimmed for external bias and differential configuration
    (uint32_t)0x000488A3,
    // Set LNA IB offset factor to 0xF
    (uint32_t)0x000F8883,
    // Rx: Set anti-aliasing filter bandwidth to 0x0 (in ADI0, set IFAMPCTL3[7:4]=0xD)
    ADI_HALFREG_OVERRIDE(0,61,0xF,0x0),
    // TX: Reduce analog ramping wait time
    HW_REG_OVERRIDE(0x6028,0x001A),
    // override_prop_common.xml
    // DC/DC regulator: In Tx with 14 dBm PA setting, use DCDCCTL5[3:0]=0xF (DITHER_EN=1 and IPEAK=7). In Rx, use default settings.
    (uint32_t)0x00F788D3,
    // override_prop_common_sub1g.xml
    // Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
    (uint32_t)0x4001405D,
    // Set RF_FSCA.ANADIV.DIV_SEL_BIAS = 1. Bits [0:16, 24, 30] are don't care..
    (uint32_t)0x08141131,
    (uint32_t)0xFFFFFFFF
};


// Overrides for CMD_PROP_RADIO_DIV_SETUP_PA
uint32_t overridesTxStd_CC1352P_915_PA[] =
{
    // The TX Power element should always be the first in the list
    TX_STD_POWER_OVERRIDE(0x013F),
    // The ANADIV radio parameter based on the LO divider (0) and front-end (0) settings
    (uint32_t)0x11310703,
    // override_phy_tx_pa_ramp_genfsk_std.xml
    // Tx: Configure PA ramping, set wait time before turning off (0x1A ticks of 16/24 us = 17.3 us).
    HW_REG_OVERRIDE(0x6028,0x001A),
    // Set TXRX pin to 0 in RX and high impedance in idle/TX.
    HW_REG_OVERRIDE(0x60A8,0x0401),
    (uint32_t)0xFFFFFFFF
};


// Overrides for CMD_PROP_RADIO_DIV_SETUP_PA
uint32_t overridesTx20_CC1352P_915_PA[] =
{
    // The TX Power element should always be the first in the list
    TX20_POWER_OVERRIDE(0x001B8ED2),
    // The ANADIV radio parameter based on the LO divider (0) and front-end (0) settings
    (uint32_t)0x11C10703,
    // override_phy_tx_pa_ramp_genfsk_hpa.xml
    // Tx: Configure PA ramping, set wait time before turning off (0x1F ticks of 16/24 us = 20.3 us).
    HW_REG_OVERRIDE(0x6028,0x001F),
    // Set TXRX pin to 0 in RX/TX and high impedance in idle.
    HW_REG_OVERRIDE(0x60A8,0x0001),
    (uint32_t)0xFFFFFFFF
};

uint32_t overrides_CC1352P_2400_SPREAD2[] = // for 2400 from RF STUDIO, TxStd and Tx20 are zero
{
 // override_phy_simplelink_long_range_dsss4.xml
 //HW_REG_OVERRIDE(0x5068,0x030C), // PHY: Configure DSSS SF=4 for payload data
 HW_REG_OVERRIDE(0x5068,0x0100), // for DSSS=2 use 0x0100, DSSS=4 use 0x0303, for DSSS=8 use 0x073C; DSSS=1 is not supported in mode 2

 // override_tc902.xml
 // DC/DC regulator: In Tx, use DCDCCTL5[3:0]=0x3 (DITHER_EN=0 and IPEAK=3).
 (uint32_t)0x00F388D3,
 // Rx: Set anti-aliasing filter bandwidth to 0x5 (in ADI0, set IFAMPCTL3[7:4]=0x5)
 ADI_HALFREG_OVERRIDE(0,61,0xF,0x5),
 // Tx: Configure PA ramp time, PACTL2.RC=0x1 (in ADI0, set PACTL2[4:3]=0x1)
 ADI_2HALFREG_OVERRIDE(0,16,0x8,0x8,17,0x1,0x0),
 // Rx: Set AGC reference level to 0x1E (default: 0x2E)
 HW_REG_OVERRIDE(0x609C,0x001E),
 // PDIFLINPREDEN = 0 (bit 3) PDIFLIMITRANGE = 1 (bit 0). Default 0x40F6 (0x40F7)
 HW_REG_OVERRIDE(0x50D4,0x40F7),
 // Enable piecewise linear shaper.
 (uint32_t)0x00810083,
 // Enable piecewise linear shaper.
 (uint32_t)0x001000A3,
 // No automatic shape programming.
 (uint32_t)0x000000C3,
 // No automatic shape programming.
 (uint32_t)0x000000E3,
 // 6 element override starting from 0x4040
 HW32_ARRAY_OVERRIDE(0x4040,6),
 // Shape override.
 (uint32_t)0x0000B19A,
 // Shape override.
 (uint32_t)0x00013199,
 // Shape override.
 (uint32_t)0x00000000,
 // Shape override.
 (uint32_t)0x00000000,
 // Shape override.
 (uint32_t)0x00000000,
 // Shape override.
 (uint32_t)0x00000000,
 // override_hposc.xml
 // HPOSC frequency offset override, freqOffset=2^22*(F_nom-F_hposc)/F_hposc
 HPOSC_OVERRIDE(0),
 (uint32_t)0xFFFFFFFF
};

uint32_t overrides_CC1352P_2400[] = // for 2400 from RF STUDIO, TxStd and Tx20 are zero
{
 // override_tc902.xml
 // DC/DC regulator: In Tx, use DCDCCTL5[3:0]=0x3 (DITHER_EN=0 and IPEAK=3).
 (uint32_t)0x00F388D3,
 // Rx: Set anti-aliasing filter bandwidth to 0x5 (in ADI0, set IFAMPCTL3[7:4]=0x5)
 ADI_HALFREG_OVERRIDE(0,61,0xF,0x5),
 // Tx: Configure PA ramp time, PACTL2.RC=0x1 (in ADI0, set PACTL2[4:3]=0x1)
 ADI_2HALFREG_OVERRIDE(0,16,0x8,0x8,17,0x1,0x0),
 // Rx: Set AGC reference level to 0x1E (default: 0x2E)
 HW_REG_OVERRIDE(0x609C,0x001E),
 // PDIFLINPREDEN = 0 (bit 3) PDIFLIMITRANGE = 1 (bit 0). Default 0x40F6 (0x40F7)
 HW_REG_OVERRIDE(0x50D4,0x40F7),
 // Enable piecewise linear shaper.
 (uint32_t)0x00810083,
 // Enable piecewise linear shaper.
 (uint32_t)0x001000A3,
 // No automatic shape programming.
 (uint32_t)0x000000C3,
 // No automatic shape programming.
 (uint32_t)0x000000E3,
 // 6 element override starting from 0x4040
 HW32_ARRAY_OVERRIDE(0x4040,6),
 // Shape override.
 (uint32_t)0x0000B19A,
 // Shape override.
 (uint32_t)0x00013199,
 // Shape override.
 (uint32_t)0x00000000,
 // Shape override.
 (uint32_t)0x00000000,
 // Shape override.
 (uint32_t)0x00000000,
 // Shape override.
 (uint32_t)0x00000000,
 // override_hposc.xml
 // HPOSC frequency offset override, freqOffset=2^22*(F_nom-F_hposc)/F_hposc
 HPOSC_OVERRIDE(0),
 (uint32_t)0xFFFFFFFF
};

// settings for LAUNCHXL_CC1352P-2, 20dBm at 2.4

uint32_t overrides_CC1352P_2400_PA_SPREAD2[] = // from 802.15.4 in RF Studio (other modes not characterized for PA at 2.4GHz)
{
 // override_phy_simplelink_long_range_dsss4.xml
 // PHY: Configure DSSS SF=4 for payload data
 //HW_REG_OVERRIDE(0x5068,0x030C),
 HW_REG_OVERRIDE(0x5068,0x0100),

    // Sivan June 2022; taken from SmartRF Studio, 802.15.4
    // override_ieee_802_15_4_10_dbm.xml
    // Rx: Set LNA bias current offset to +15 to saturate trim to max (default: 0)
    (uint32_t)0x000F8883,
    // Set VCTRIM to 0 for 20 dBm PA
    ADI_REG_OVERRIDE(1,26,0x00),
    // override_hposc.xml
    // HPOSC frequency offset override, freqOffset=2^22*(F_nom-F_hposc)/F_hposc
    HPOSC_OVERRIDE(0),
    (uint32_t)0xFFFFFFFF
};



uint32_t overrides_CC1352P_2400_PA[] = // from 802.15.4 in RF Studio (other modes not characterized for PA at 2.4GHz)
{
    // Sivan June 2022; taken from SmartRF Studio, 802.15.4
    // override_ieee_802_15_4_10_dbm.xml
    // Rx: Set LNA bias current offset to +15 to saturate trim to max (default: 0)
    (uint32_t)0x000F8883,
    // Set VCTRIM to 0 for 20 dBm PA
    ADI_REG_OVERRIDE(1,26,0x00),
    // override_hposc.xml
    // HPOSC frequency offset override, freqOffset=2^22*(F_nom-F_hposc)/F_hposc
    HPOSC_OVERRIDE(0),
    (uint32_t)0xFFFFFFFF
};


// Overrides for CMD_RADIO_SETUP_PA
uint32_t overridesTxStd_CC1352P_2400_PA[] = // from 802.15.4 in RF Studio
{
 // The TX Power element should always be the first in the list
 TX_STD_POWER_OVERRIDE(0x7217),
 // The ANADIV radio parameter based on the LO divider (0) and front-end (0) settings
 (uint32_t)0x05320703,
 // override_txstd_settings_10_dbm.xml
 // Set RTIM offset to default for standard PA
 (uint32_t)0x00008783,
 // Set synth mux to default value for standard PA
 (uint32_t)0x050206C3,
 // Set TXRX pin to 0 in RX and high impedance in idle/TX.
 HW_REG_OVERRIDE(0x60A8,0x0401),
 // Tx: Set DCDC settings IPEAK=3, dither = off
 (uint32_t)0x00F388D3,
 (uint32_t)0xFFFFFFFF
};

// from e2e (TER): should not be used if you power the HPA (20 dBm) PA from VDDS
// Set VCTRIM to 0 for 20 dBm PA
//ADI_HALFREG_OVERRIDE(1,26,0xF,0x0),
// Set VCTRIM to 0 for 20 dBm PA
//ADI_HALFREG_OVERRIDE(1,27,0x7,0x0),

// Overrides for CMD_RADIO_SETUP_PA
uint32_t overridesTx20_CC1352P_2400_PA[] = // from 802.15.4 in RF Studio
{
 // The TX Power element should always be the first in the list
 TX20_POWER_OVERRIDE(0x00104F66),
 //TX20_POWER_OVERRIDE(0x00103F5F), // 9dbm, etc
 // The ANADIV radio parameter based on the LO divider (0) and front-end (0) settings
 (uint32_t)0x01C20703,
 // override_tx10dbm_settings.xml
 // Set RTIM offset to 3 for high power PA
 (uint32_t)0x00038783,
 // Set synth mux for high power PA
 (uint32_t)0x010206C3,
 // Set TXRX pin to 0 in RX/TX and high impedance in idle.
 HW_REG_OVERRIDE(0x60A8,0x0001),
 // Tx: Set DCDC settings IPEAK=7, dither = off
 (uint32_t)0x00F788D3,
 (uint32_t)0xFFFFFFFF
};

#endif

void radioSetup_packetFormat(uint32_t index, int8_t packetFormat) {
  //packet_format[index] = packetFormat; // keep around for txPower

  switch (packetFormat) {
  case DATA_ENCODING_CC1310_MODE2LRM:
    //System_printf("enc mode2lrm\n");
    radio_cmd_prop_div_setup[index].formatConf.fecMode    = 0x08; // LRM
    radio_cmd_prop_div_setup[index].preamConf.nPreamBytes = 5; // this sets M, where M+1 is the number of repetition of a fixed sync word
    radio_cmd_prop_div_setup[index].formatConf.whitenMode = 0x1; // required for mode 2.
    break;
  case DATA_ENCODING_CC1310_FASTLRM:
    //System_printf("enc fastlrm\n");
    radio_cmd_prop_div_setup[index].formatConf.fecMode = 0; // weird, but this is the setup from SVS
    break;
  case DATA_ENCODING_CC1310_LRM:
    //System_printf("enc lrm MISSING\n");
    break;
  case DATA_ENCODING_PLAIN:
  default:
    //System_printf("enc plain\n");
    radio_cmd_prop_div_setup[index].formatConf.fecMode = 0;
    radio_cmd_prop_div_setup[index].formatConf.whitenMode = 0x0;
    break;
  }

  uint8_t lo = loForSetup[index];

  if (packetFormat==DATA_ENCODING_CC1310_MODE2LRM) {

#ifdef DeviceFamily_CC13X0
    radio_cmd_prop_div_setup[index].pRegOverride = overrides_mode2;
    radio_mode[index].cpePatchFxn = &rf_patch_cpe_sl_longrange;
    radio_mode[index].mcePatchFxn = &rf_patch_mce_sl_longrange;
    radio_mode[index].rfePatchFxn = &rf_patch_rfe_sl_longrange;
#endif
#ifdef DeviceFamily_CC13X2
    if (lo <=2)
        radio_cmd_prop_div_setup[index].pRegOverride = overrides_2400_mode2_sf4;
    else
        radio_cmd_prop_div_setup[index].pRegOverride = overrides_mode2;

#endif
  }

  if (packetFormat==DATA_ENCODING_CC1310_FASTLRM) {
    //System_printf("enc fastlrm\n");
    radio_cmd_prop_div_setup[index].pRegOverride = overrides_fastlrm;

#ifdef DeviceFamily_CC13X0
    radio_mode[index].cpePatchFxn = &rf_patch_cpe_genfsk;
    radio_mode[index].mcePatchFxn = &enterLrmMcePatch;
    radio_mode[index].rfePatchFxn = 0;
#endif
  }

  //  case DATA_ENCODING_CC1310_LRM:

  if (packetFormat==DATA_ENCODING_PLAIN) {
    switch (lo) {
    case 0:
    case 2:
      radio_cmd_prop_div_setup[index].pRegOverride = overrides_2400;
      break;
    case 10:
      radio_cmd_prop_div_setup[index].pRegOverride = overrides_434;    // for SDK 2.1 and up
      break;
    case 5:
    default:
      radio_cmd_prop_div_setup[index].pRegOverride = overrides_915; // for SDK 2.1 and up
      break;
    }
#ifdef DeviceFamily_CC13X0
    radio_mode[index].cpePatchFxn = &rf_patch_cpe_genfsk;
    radio_mode[index].mcePatchFxn = 0;
    radio_mode[index].rfePatchFxn = &rf_patch_rfe_genfsk;
#endif
    }

#ifdef DeviceFamily_CC13X2
    radio_mode[index].cpePatchFxn = &rf_patch_cpe_prop;
    radio_mode[index].mcePatchFxn = 0;
    radio_mode[index].rfePatchFxn = 0;
#endif


#ifdef MOVED
	switch (packetFormat) {
  case DATA_ENCODING_CC1310_MODE2LRM:
    System_printf("enc mode2lrm\n");
    radio_cmd_prop_div_setup[index].formatConf.fecMode = 0x08; // LRM
    radio_cmd_prop_div_setup[index].pRegOverride = overrides_mode2lrm;
    radio_cmd_prop_div_setup[index].preamConf.nPreamBytes = 5; // this sets M, where M+1 is the number of repetition of a fixed sync word
    radio_cmd_prop_div_setup[index].formatConf.whitenMode = 0x1; // required for mode 2.

#ifdef DeviceFamily_CC13X0
    radio_mode[index].cpePatchFxn = &rf_patch_cpe_sl_longrange;
    radio_mode[index].mcePatchFxn = &rf_patch_mce_sl_longrange;
    radio_mode[index].rfePatchFxn = &rf_patch_rfe_sl_longrange;
#endif
    break;
  case DATA_ENCODING_CC1310_FASTLRM:
    System_printf("enc fastlrm\n");
    radio_cmd_prop_div_setup[index].formatConf.fecMode = 0; // weird, but this is the setup from SVS
    radio_cmd_prop_div_setup[index].pRegOverride = overrides_fastlrm;

#ifdef DeviceFamily_CC13X0
    radio_mode[index].cpePatchFxn = &rf_patch_cpe_genfsk;
    radio_mode[index].mcePatchFxn = &enterLrmMcePatch;
    radio_mode[index].rfePatchFxn = 0;
#endif
    break;
	case DATA_ENCODING_CC1310_LRM:
		System_printf("enc lrm MISSING\n");
#if 0
		radio_cmd_prop_div_setup[index].formatConf.fecMode = 8;
		radio_cmd_prop_div_setup[index].pRegOverride = lrmOverrides;

#ifdef DeviceFamily_CC13X0
		radio_mode[index].cpePatchFxn = &rf_patch_cpe_lrm;
		radio_mode[index].mcePatchFxn = 0;
		radio_mode[index].rfePatchFxn = 0;
#endif
#endif
		break;
	case DATA_ENCODING_PLAIN:
	default:
		System_printf("enc plain\n");
		radio_cmd_prop_div_setup[index].formatConf.fecMode = 0;
    //radio_cmd_prop_div_setup[index].pRegOverride = gfskOverrides;
		if (radio_cmd_prop_div_setup[index].loDivider==10)
		    radio_cmd_prop_div_setup[index].pRegOverride = overrides_434;  // for SDK 2.1 and up
		else // div==5
            radio_cmd_prop_div_setup[index].pRegOverride = overrides_915;  // for SDK 2.1 and up

#ifdef DeviceFamily_CC13X0
    radio_mode[index].cpePatchFxn = &rf_patch_cpe_genfsk;
		radio_mode[index].mcePatchFxn = 0;
		radio_mode[index].rfePatchFxn = &rf_patch_rfe_genfsk;
#endif
#ifdef defined(SHOULD_NOT_BE_HERE) && defined(DeviceFamily_CC13X2)
	if (radio_cmd_prop_div_setup[index].loDivider==10)
	    radio_cmd_prop_div_setup[index].pRegOverride = overrides_CC1352P_434; // overridesCC1352P_data;
    if (radio_cmd_prop_div_setup[index].loDivider==2)
        radio_cmd_prop_div_setup[index].pRegOverride = overrides_CC1352P_2400;

    radio_cmd_prop_div_setup[index].pRegOverrideTxStd = 0;
    radio_cmd_prop_div_setup[index].pRegOverrideTx20  = 0;

    radio_mode[index].cpePatchFxn = &rf_patch_cpe_prop;
    radio_mode[index].mcePatchFxn = 0;
    radio_mode[index].rfePatchFxn = 0;
#endif
		break;
	}
#endif
}

/********************************************************/
/* POWER TABLES                                         */
/********************************************************/


#ifdef OBSOLETE
#ifdef DeviceFamily_CC13X0
// smartrf also shows -10dBm --> 0x08c0
static const int8_t power_setting_start = 0;
static const uint16_t power_setting[] = {
    0x0041, // 0dBm
    0x10c3,
    0x1042,
    0x14c4, // 0dBm
    0x18c5,
    0x18c6, // 5
    0x1cc7,
    0x20c9,
    0x24cb,
    0x2ccd, // 9
    0x38d3, // 10dBm 0x7217
    0x50da, // 11
    0xb818, // 12
    0xa63f, // 12.5dBm
    0xa73f // 14dBm (if VDDR boost)
};

void radioSetup_txPower(uint32_t index, int8_t dbm) {
    dbmForSetup[index] = dbm;
    System_printf("power setting 0x%04x\n",power_setting[ dbm - power_setting_start ]);
    radio_cmd_prop_div_setup[index].txPower = power_setting[ dbm - power_setting_start ];
}
#endif
#endif

typedef struct power_table_entry_st {
    int8_t dBm;
    uint16_t code;
} power_table_entry_t;
//static const int8_t power_setting_start = 0;

#ifdef DeviceFamily_CC13X2
static const power_table_entry_t power_setting_434[] = {
    {10, 0x5890}, // 0x38d3, // 10dBm 0x7217
    { 0, 0x20c9},
    { 1, 0x20ca},
    { 2, 0x26cc},
    { 3, 0x2ece}, // 0dBm
    { 4, 0x2ed0},
    { 5, 0x40d6}, // 5
    { 6, 0x00d2},
    { 7, 0x46da},
    { 8, 0x58e0},
    { 9, 0x66E8}, // 9

    {11, 0x8098}, // 11
    {12, 0x9413}, // 12
    {13, 0x003f}, // 13dBm
    {0, 0},
};
static const power_table_entry_t power_setting_2400[] = {
    {5, 0x7217}, // 5

    {0, 0x2853}, // 0dBm
    {1, 0x2856},
    {2, 0x3259},
    {3, 0x385d}, // 0dBm
    {4, 0x4e63},
    {0, 0},
    // 0x0acf for -10, 0x04c6 for -20, for testing
};
#endif

#ifdef DeviceFamily_CC13X0
static const power_table_entry_t const power_setting_434[] = {
    {10, 0x38d3}, // 10dBm
    { 0, 0x0041},
    { 1, 0x10c3},
    { 2, 0x1042},
    { 3, 0x14c4}, // 3dBm
    { 4, 0x18c5},
    { 5, 0x18c6}, // 5
    { 6, 0x1cc7},
    { 7, 0x20c9},
    { 8, 0x24cb},
    { 9, 0x2ccd}, // 9

    {11, 0x50da}, // 11
    {12, 0xb818}, // 12
    {13, 0xa63f}, // 12.5dBm
    {14, 0xa73f},
    {0, 0},
};

static const power_table_entry_t const power_setting_2400[] = {
    { 5, 0x5f3c}, // 5
    { 0, 0x5b1d},
    // copied from 434 from here on
    { 1, 0x10c3},
    { 2, 0x1042},
    { 3, 0x14c4}, // 3dBm
    { 4, 0x18c5},

    { 6, 0x1cc7},
    { 7, 0x20c9},
    { 8, 0x24cb},
    { 9, 0x3d3f}, // 9
    {0, 0},
};

#endif

void radioSetup_txPower(uint32_t index, int8_t dbm) {
  //uint8_t format = packet_format[index];
  uint8_t pa     = false;
  uint8_t lo     = loForSetup[index]; //lo_divider[index];

  //dbm=5;
  //dbmForSetup[index] = dbm;

#ifdef DeviceFamily_CC13X2
  if (lo==2 && dbm > 5 ) pa = true;
  if (lo!=2 && dbm > 14) pa = true;
  System_printf("pa %d dbm %d lo %d\n",pa,dbm,lo);
#endif

//#ifdef FORCE_PA
//    dbm=20;
//    pa = true;
//#endif

  if (!pa) {
        const power_table_entry_t * table;
        switch (lo) {
        case 0:
        case 2:
            table = power_setting_2400;
            break;
        case 10:
        default:
            table = power_setting_434;
            break;
        }

        uint16_t code = table[0].code; // default
        int i;
        for (i=0; table[i].code != 0; i++)
          if (table[i].dBm == dbm) code = table[i].code;

        //System_printf("power setting %d dBm code 0x%04x (no PA)\n",dbm, code);
        radio_cmd_prop_div_setup[index].txPower = code;

#ifdef DeviceFamily_CC13X2
#ifdef CC26X2
        if (lo>2) {
          radio_cmd_prop_div_setup[index].pRegOverrideTxStd = 0;
          radio_cmd_prop_div_setup[index].pRegOverrideTx20  = 0;
        } else {
            //radio_cmd_prop_div_setup[index].pRegOverrideTxStd = 0;
            //radio_cmd_prop_div_setup[index].pRegOverrideTx20  = 0;
            //System_printf("no div no pa %x\n",radio_cmd_prop_div_setup[index].commandNo);

            radio_cmd_prop_div_setup[index].commandNo = 0x3806; // change to CMD_PROP_RADIO_SETUP, no divider
            rfc_CMD_PROP_RADIO_SETUP_PA_t* setup = (rfc_CMD_PROP_RADIO_SETUP_PA_t*) &(radio_cmd_prop_div_setup[index]);
            setup->pRegOverrideTxStd = 0;
            setup->pRegOverrideTx20  = 0;
            System_printf("%d: no div no pa %x\n",index,setup->commandNo);
        }
#else
        radio_cmd_prop_div_setup[index].pRegOverrideTxStd = 0;
        radio_cmd_prop_div_setup[index].pRegOverrideTx20  = 0;
#endif
#endif
  } else { // pa
        //System_printf("power setting %d dBm (PA)\n",dbm);
        radio_cmd_prop_div_setup[index].txPower = 0xFFFF;

#ifdef DeviceFamily_CC13X2
#ifdef CC26X2
        if (lo>2) {
            radio_cmd_prop_div_setup[index].pRegOverrideTxStd = overrides_txstd_915; // need to find overrides for sub1ghz
            radio_cmd_prop_div_setup[index].pRegOverrideTx20  = overrides_tx20_915;
        } else {
            //radio_cmd_prop_div_setup[index].pRegOverrideTxStd = overrides_txstd_2400;
            //radio_cmd_prop_div_setup[index].pRegOverrideTx20  = overrides_tx20_2400;
            //System_printf("no div pa %x\n",radio_cmd_prop_div_setup[index].commandNo);

            radio_cmd_prop_div_setup[index].commandNo = 0x3806; // change to CMD_PROP_RADIO_SETUP, no divider
            rfc_CMD_PROP_RADIO_SETUP_PA_t* setup = (rfc_CMD_PROP_RADIO_SETUP_PA_t*) &(radio_cmd_prop_div_setup[index]);
            setup->pRegOverrideTxStd = overrides_txstd_2400;
            setup->pRegOverrideTx20  = overrides_tx20_2400;
            System_printf("%d: no div pa %x %08x %08x %04x\n",index,setup->commandNo, setup->pRegOverrideTxStd,setup->pRegOverrideTx20, setup->txPower );
        }
#else

        // changed sivan july 2022; did not transmit with PA in the existing settings...
        radio_cmd_prop_div_setup[index].pRegOverride      = overrides_915_1mbs_pa;
        radio_cmd_prop_div_setup[index].pRegOverrideTxStd = overrides_txstd_915;
        radio_cmd_prop_div_setup[index].pRegOverrideTx20  = overrides_tx20_915;
        //radio_cmd_prop_div_setup[index].pRegOverride      = overrides_CC1352P_915_PA_915;
        //radio_cmd_prop_div_setup[index].pRegOverrideTxStd = overridesTxStd_CC1352P_915_PA;
        //radio_cmd_prop_div_setup[index].pRegOverrideTx20  = overridesTx20_CC1352P_915_PA;
#endif
#endif
  }
}

/********************************************************/
/* COMMAND-STRUCTURE TABLES                             */
/********************************************************/

// CMD_NOP
rfc_CMD_NOP_t radio_cmd_nop = {
    .commandNo = CMD_NOP, // 0x0801,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = TRIG_NOW, // 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,
};



#ifdef DeviceFamily_CC13X2
rfc_CMD_PROP_RADIO_DIV_SETUP_PA_t radio_cmd_prop_div_setup[MAX_RADIO_SETUPS] = {
{
    .commandNo = 0x3807,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,
    .modulation.modType = 0x1,
    .modulation.deviation = 0xC8,
    .modulation.deviationStepSz = 0x0,
    .symbolRate.preScale = 0xF,
    .symbolRate.rateWord = 0x20000,
    .symbolRate.decimMode = 0x0,
    .rxBw = 0x58,
    .preamConf.nPreamBytes = 0x4,
    .preamConf.preamMode = 0x0,
    .formatConf.nSwBits = 0x20,
    .formatConf.bBitReversal = 0x0,
    .formatConf.bMsbFirst = 0x1,
    .formatConf.fecMode = 0x0,
    .formatConf.whitenMode = 0x0,
    .config.frontEndMode = 0x0,
    .config.biasMode = 0x1,
    .config.analogCfgMode = 0x0,
    .config.bNoFsPowerUp = 0x0,
    //.config.bSynthNarrowBand = 0x0, // Sivan seems to be for SDK 4 only
    .txPower = 0x5890,
    .pRegOverride = 0,
    .centerFreq = 0x01B1,
    .intFreq = 0x0999,
    .loDivider = 0x0A,
    .pRegOverrideTxStd = 0,
    .pRegOverrideTx20 = 0
}};
#else
rfc_CMD_PROP_RADIO_DIV_SETUP_t radio_cmd_prop_div_setup[MAX_RADIO_SETUPS] = {
{
    .commandNo = CMD_PROP_RADIO_DIV_SETUP,
    .status = IDLE,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = TRIG_NOW, //0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,

    .modulation.modType = 0x1,
    .modulation.deviation = 0x64,
    .symbolRate.preScale = 0xF,
    .symbolRate.rateWord = 0x8000,
    .rxBw = 0x24,
    .preamConf.nPreamBytes = 5, //0x4,
    .preamConf.preamMode = 0x0,
    .formatConf.nSwBits = 32, //0x20,
    .formatConf.bBitReversal = 0x0,
    .formatConf.bMsbFirst = 0x1,
    .formatConf.fecMode = 0x0,
    .formatConf.whitenMode = 0x0,
    .config.frontEndMode = 0x0,
    .config.biasMode = 0x1,
    .config.analogCfgMode = 0x0,
    .config.bNoFsPowerUp = 0x0,
    .txPower = 0x38D3,
    .pRegOverride = 0, // will be set later lrmOverrides,
    .centerFreq = 0x0364,
    .intFreq = 0x8000,
    .loDivider = 0x05,}};
#endif

// CMD_FS
rfc_CMD_FS_t radio_cmd_fs[MAX_RADIO_SETUPS] = {
{
    .commandNo = CMD_FS, // 0x0803,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = TRIG_NOW, // 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,
    .frequency = 0x0364,
    .fractFreq = 0x0000,
    .synthConf.bTxMode = 0x0,
    .synthConf.refFreq = 0x0,
    .__dummy0 = 0x00,
    .__dummy1 = 0x00,
    .__dummy2 = 0x00,
    .__dummy3 = 0x0000,
}};

// CMD_PROP_TX
rfc_CMD_PROP_TX_t radio_cmd_prop_tx[MAX_RADIO_SETUPS] = {
  {
    .commandNo = CMD_PROP_TX, // 0x3801,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,

    .pktConf.bFsOff = 0x0,
    .pktConf.bUseCrc = 0x1,
    .pktConf.bVarLen = 0x1,
    .pktLen = 0x1E, // SET APPLICATION PAYLOAD LENGTH
    .syncWord = 0x930B51DE,
    .pPkt = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
  }
};

// CMD_PROP_RX
rfc_CMD_PROP_RX_t radio_cmd_prop_rx[MAX_RADIO_SETUPS] = {
{
      .commandNo = CMD_PROP_RX, // 0x3802,
	  	.status = 0x0000,
		  .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
	  	.startTime = 0x00000000,
  		.startTrigger.triggerType = 0x0,
	    .startTrigger.bEnaCmd = 0x0,
	    .startTrigger.triggerNo = 0x0,
	    .startTrigger.pastTrig = 0x0,
	    .condition.rule = 0x1,
	    .condition.nSkip = 0x0,

			.pktConf.bFsOff = 0x0,
	    .pktConf.bRepeatOk = 0x1,
	    .pktConf.bRepeatNok = 0x1,
	    .pktConf.bUseCrc = 0x1,
	    .pktConf.bVarLen = 0x1,
	    .pktConf.bChkAddress = 0x0,
	    .pktConf.endType = 0x0,
	    .pktConf.filterOp = 0x0,
	    .rxConf.bAutoFlushIgnored = 0x0,
	    .rxConf.bAutoFlushCrcErr = 0x0,
	    .rxConf.bIncludeHdr = 0x1,
	    .rxConf.bIncludeCrc = 0x0,
	    .rxConf.bAppendRssi = 0x1,
	    .rxConf.bAppendTimestamp = 0x1,
	    .rxConf.bAppendStatus = 0x1,
	    .syncWord = 0x930B51DE,
	    .maxPktLen = 0x80, // MAKE SURE DATA ENTRY IS LARGE ENOUGH
	    .address0 = 0xAA,
	    .address1 = 0xBB,
	    .endTrigger.triggerType = TRIG_NEVER, // 0x1,
	    .endTrigger.bEnaCmd = 0x0,
	    .endTrigger.triggerNo = 0x0,
	    .endTrigger.pastTrig = 0x0,
	    .endTime = 0x00000000,
	    .pQueue = 0, // INSERT APPLICABLE POINTER: (dataQueue_t*)&xxx
	    .pOutput = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
}};

// CMD_PROP_RX_ADV
rfc_CMD_PROP_RX_ADV_t RF_cmdPropRxAdv =
{
    .commandNo = 0x3804,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,

		.pktConf.bFsOff = 0x0,
    .pktConf.bRepeatOk = 0x0,
    .pktConf.bRepeatNok = 0x0,
    .pktConf.bUseCrc = 0x0,
    .pktConf.bCrcIncSw = 0x0,
    .pktConf.bCrcIncHdr = 0x0,
    .pktConf.endType = 0x0,
    .pktConf.filterOp = 0x0,
    .rxConf.bAutoFlushIgnored = 0x0,
    .rxConf.bAutoFlushCrcErr = 0x0,
    .rxConf.bIncludeHdr = 0x0,
    .rxConf.bIncludeCrc = 0x0,
    .rxConf.bAppendRssi = 0x0,
    .rxConf.bAppendTimestamp = 0x0,
    .rxConf.bAppendStatus = 0x0,
    .syncWord0 = 0x00000000,
    .syncWord1 = 0x00000000,
    .maxPktLen = 0x0000,
    .hdrConf.numHdrBits = 0x0,
    .hdrConf.lenPos = 0x0,
    .hdrConf.numLenBits = 0x0,
    .addrConf.addrType = 0x0,
    .addrConf.addrSize = 0x0,
    .addrConf.addrPos = 0x0,
    .addrConf.numAddr = 0x0,
    .lenOffset = 0x00,
    .endTrigger.triggerType = 0x0,
    .endTrigger.bEnaCmd = 0x0,
    .endTrigger.triggerNo = 0x0,
    .endTrigger.pastTrig = 0x0,
    .endTime = 0x00000000,
    .pAddr = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .pQueue = 0, // INSERT APPLICABLE POINTER: (dataQueue_t*)&xxx
    .pOutput = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
};

rfc_CMD_PROP_TX_ADV_t radio_cmd_prop_tx_adv[MAX_RADIO_SETUPS] = {
{
    .commandNo = CMD_PROP_TX_ADV,
    .status = IDLE,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,

    .pktConf.bFsOff = 0x0,
    .pktConf.bUseCrc    = 1,
    .pktConf.bCrcIncSw  = 0,
    .pktConf.bCrcIncHdr = 1, // 1 here is the equivalent of CMD_PROP_TX
    .numHdrBits         = 8, // 8 here is the equivalent of CMD_PROP_TX
    .pktLen             = 0x0000,
    .startConf.bExtTxTrig   = 0,
    .startConf.inputMode    = 0,
    .startConf.source       = 0,
    .preTrigger.triggerType = TRIG_NOW,
    .preTrigger.bEnaCmd     = 0,
    .preTrigger.triggerNo   = 0,
    .preTrigger.pastTrig    = 1,
    .preTime                = 0,
    .syncWord = 0x930B51DE,
    .pPkt = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
}
};

#if 0
/*******************************************************************************/
/* values for mode 2 LRM from SmartRF Studio, Sep 2019                         */
/*******************************************************************************/

// Deviation: 25.000 kHz
// Packet Length Config: Variable
// Max Packet Length: 255
// Packet Length: 20
// Packet Data: 255
// RX Filter BW: 155 kHz
// Symbol Rate: 100.00000 kBaud
// Sync Word Length: 32 Bits
// TX Power: 10 dBm (requires define CCFG_FORCE_VDDR_HH = 0 in ccfg.c, see CC13xx/CC26xx Technical Reference Manual)
// Whitening: CC1101/CC2500 compatible

RF_Mode radio_mode_mode2lrm = {
    .cpePatchFxn = &rf_patch_cpe_sl_longrange,
    .mcePatchFxn = &rf_patch_mce_sl_longrange,
    .rfePatchFxn = &rf_patch_rfe_sl_longrange
}

// Overrides for CMD_PROP_RADIO_DIV_SETUP

rfc_CMD_PROP_RADIO_DIV_SETUP_t radio_cmd_prop_div_setup_mode2lrm =
{
    .commandNo = 0x3807,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,
    .modulation.modType = 0x1,
    .modulation.deviation = 0x64,
    .symbolRate.preScale = 0xF,
    .symbolRate.rateWord = 0x10000,
    .symbolRate.decimMode = 0x0,
    .rxBw = 0x26,
    .preamConf.nPreamBytes = 0x2, // this is M; mode sends M+1 sync words, last is inverted
    .preamConf.preamMode = 0x0,   // no preampble in this mode
    .formatConf.nSwBits = 0x20,
    .formatConf.bBitReversal = 0x0,
    .formatConf.bMsbFirst = 0x0,
    .formatConf.fecMode = 0x8,
    .formatConf.whitenMode = 0x1,
    .config.frontEndMode = 0x0,
    .config.biasMode = 0x1,
    .config.analogCfgMode = 0x0,
    .config.bNoFsPowerUp = 0x0,
    .txPower = 0x46CB,
    .pRegOverride = overrides_mode2lrm,
    .centerFreq = 0x01B1,
    .intFreq = 0x8000,
    .loDivider = 0x0A
};


// CMD_FS
// Frequency Synthesizer Programming Command
rfc_CMD_FS_t radio_cmd_fs_mode2lrm =
{
    .commandNo = 0x0803,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,
    .frequency = 0x01B1,
    .fractFreq = 0xEB9A,
    .synthConf.bTxMode = 0x0,
    .synthConf.refFreq = 0x0,
    .__dummy0 = 0x00,
    .__dummy1 = 0x00,
    .__dummy2 = 0x00,
    .__dummy3 = 0x0000
};


rfc_CMD_PROP_TX_t radio_cmd_prop_tx_mode2lrm = {
    .commandNo = 0x3801,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,
    .pktConf.bFsOff = 0x0,
    .pktConf.bUseCrc = 0x1,
    .pktConf.bVarLen = 0x1,
    .pktLen = 0x14, // SET APPLICATION PAYLOAD LENGTH
    .syncWord = 0x00000000, // ignored in LRM
    .pPkt = 0 // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
};


// CMD_PROP_RX
// Proprietary Mode Receive Command
rfc_CMD_PROP_RX_t radio_cmd_prop_rx_mode2lrm =
{
    .commandNo = 0x3802,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,
    .pktConf.bFsOff = 0x0,
    .pktConf.bRepeatOk = 0x0,
    .pktConf.bRepeatNok = 0x0,
    .pktConf.bUseCrc = 0x1,
    .pktConf.bVarLen = 0x1,
    .pktConf.bChkAddress = 0x0,
    .pktConf.endType = 0x0,
    .pktConf.filterOp = 0x0,

    .rxConf.bAutoFlushIgnored = 0x1,
    .rxConf.bAutoFlushCrcErr = 0x1,
    .rxConf.bIncludeHdr = 0x1,
    .rxConf.bIncludeCrc = 0x0,
    .rxConf.bAppendRssi = 0x1,
    .rxConf.bAppendTimestamp = 0x1,
    .rxConf.bAppendStatus = 0x1,

    .syncWord = 0x00000000, // this is ignored
    .maxPktLen = 0xFF, // MAKE SURE DATA ENTRY IS LARGE ENOUGH
    .address0 = 0xAA,
    .address1 = 0xBB,
    .endTrigger.triggerType = 0x1,
    .endTrigger.bEnaCmd = 0x0,
    .endTrigger.triggerNo = 0x0,
    .endTrigger.pastTrig = 0x0,
    .endTime = 0x00000000,
    .pQueue = 0, // INSERT APPLICABLE POINTER: (dataQueue_t*)&xxx
    .pOutput = 0 // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
};

// copied from fastlrm, but it's not really used at all
rfc_CMD_PROP_TX_ADV_t radio_cmd_prop_tx_adv_mode2lrm =
{
    .commandNo = CMD_PROP_TX_ADV,
    .status = IDLE,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,

    .pktConf.bFsOff = 0x0,
    .pktConf.bUseCrc    = 1,
    .pktConf.bCrcIncSw  = 0,
    .pktConf.bCrcIncHdr = 1, // 1 here is the equivalent of CMD_PROP_TX
    .numHdrBits         = 8, // 8 here is the equivalent of CMD_PROP_TX
    .pktLen             = 0x0000,

    .startConf.bExtTxTrig   = 0,
    .startConf.inputMode    = 0,
    .startConf.source       = 0,
    .preTrigger.triggerType = TRIG_NOW,
    .preTrigger.bEnaCmd     = 0,
    .preTrigger.triggerNo   = 0,
    .preTrigger.pastTrig    = 1,
    .preTime                = 0,

    //.syncWord = 0x930B51DE,
    .syncWord = 0x333C3C33,
    .pPkt = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
};


void radioSetup_setMode2LRM(uint32_t i) {
  radio_mode              [i] = radio_mode_mode2lrm              ;
  radio_cmd_prop_div_setup[i] = radio_cmd_prop_div_setup_mode2lrm;
  radio_cmd_prop_tx       [i] = radio_cmd_prop_tx_mode2lrm       ;
  radio_cmd_prop_tx_adv   [i] = radio_cmd_prop_tx_adv_mode2lrm   ;
  radio_cmd_prop_rx       [i] = radio_cmd_prop_rx_mode2lrm       ;
  radio_cmd_fs            [i] = radio_cmd_fs_mode2lrm            ;
}


/*******************************************************************************/
/* values received from TI empolyee SVD on E2E                                 */
/*******************************************************************************/

// TI-RTOS RF Mode Object
RF_Mode radio_mode_fastlrm =
{
    .rfMode = RF_MODE_PROPRIETARY_SUB_1, //RF_MODE_PROPRIETARY,
    .cpePatchFxn = &rf_patch_cpe_genfsk,
    .mcePatchFxn = &enterLrmMcePatch,
    .rfePatchFxn = 0,
};


// CMD_PROP_RADIO_DIV_SETUP
rfc_CMD_PROP_RADIO_DIV_SETUP_t radio_cmd_prop_div_setup_fastlrm =
{
    .commandNo = 0x3807,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,
    .modulation.modType = 0x0,          //Changed for LRM mode
    .modulation.deviation = 0x2BC,      //175KHz deviation (250*700)
    .symbolRate.preScale = 0xf,         //Prescalar value of 15
    .symbolRate.rateWord = 0x50000,     //500kbps with prescalar of 15.
    .rxBw = 0x2F,                       //1410KHz bandwidth
    .preamConf.nPreamBytes = 0x4,
    .preamConf.preamMode = 0x0,
    .formatConf.nSwBits = 0x20,         //32 bit Sync word
    .formatConf.bBitReversal = 0x0,
    .formatConf.bMsbFirst = 0x0,        //LSB transmitted first for LRM mode
    .formatConf.fecMode = 0x0,          //Uncoded
    .formatConf.whitenMode = 0x0,
    .config.frontEndMode = 0x0,         //Differential
    .config.biasMode = 0x1,             //External Bias
    .config.bNoFsPowerUp = 0x0,
    .txPower = 0xa73f,
    .pRegOverride = overrides_fastlrm,
    .centerFreq = 0x0393,
    .intFreq = 0x8000,                  //TX IF default, 1MHz IF for RX
    .loDivider = 0x05,
};

// CMD_FS
rfc_CMD_FS_t radio_cmd_fs_fastlrm =
{
    .commandNo = 0x0803,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,
    .frequency = 0x0393,                //915MHz frequency
    .fractFreq = 0x0000,
    .synthConf.bTxMode = 0x0,
    .synthConf.refFreq = 0x0,
    .__dummy0 = 0x00,
    .__dummy1 = 0x00,
    .__dummy2 = 0x00,
    .__dummy3 = 0x0000,
};

// CMD_PROP_TX
rfc_CMD_PROP_TX_t radio_cmd_prop_tx_fastlrm =
{
    .commandNo = 0x3801,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,
    .pktConf.bFsOff = 0x0,
    .pktConf.bUseCrc = 0x1,
    .pktConf.bVarLen = 0x1,
    .pktLen = 0x1e, // SET APPLICATION PAYLOAD LENGTH
    .syncWord = 0x333C3C33,
    .pPkt = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
};

// CMD_PROP_RX
rfc_CMD_PROP_RX_t radio_cmd_prop_rx_fastlrm =
{
    .commandNo = 0x3802,
    .status = 0x0000,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,

    .pktConf.bFsOff = 0x0,
    .pktConf.bRepeatOk = 0x0,
    .pktConf.bRepeatNok = 0x0,
    .pktConf.bUseCrc = 0x1,
    .pktConf.bVarLen = 0x1,
    .pktConf.bChkAddress = 0x0,
    .pktConf.endType = 0x0,
    .pktConf.filterOp = 0x0,
    .rxConf.bAutoFlushIgnored = 0x1,
    .rxConf.bAutoFlushCrcErr = 0x1,
    .rxConf.bIncludeHdr = 0x1,
    .rxConf.bIncludeCrc = 0x0,
    .rxConf.bAppendRssi = 0x1,
    .rxConf.bAppendTimestamp = 0x1,
    .rxConf.bAppendStatus = 0x1,
		.syncWord = 0x333C3C33,
    .maxPktLen = 100, // MAKE SURE DATA ENTRY IS LARGE ENOUGH
    .address0 = 0xaa,
    .address1 = 0xbb,
    .endTrigger.triggerType = 0x1,
    .endTrigger.bEnaCmd = 0x0,
    .endTrigger.triggerNo = 0x0,
    .endTrigger.pastTrig = 0x0,
    .endTime = 0x00000000,
    .pQueue = 0, // INSERT APPLICABLE POINTER: (dataQueue_t*)&xxx
    .pOutput = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
};

rfc_CMD_PROP_TX_ADV_t radio_cmd_prop_tx_adv_fastlrm =
{
    .commandNo = CMD_PROP_TX_ADV,
    .status = IDLE,
    .pNextOp = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
    .startTime = 0x00000000,
    .startTrigger.triggerType = 0x0,
    .startTrigger.bEnaCmd = 0x0,
    .startTrigger.triggerNo = 0x0,
    .startTrigger.pastTrig = 0x0,
    .condition.rule = 0x1,
    .condition.nSkip = 0x0,

		.pktConf.bFsOff = 0x0,
    .pktConf.bUseCrc    = 1,
    .pktConf.bCrcIncSw  = 0,
    .pktConf.bCrcIncHdr = 1, // 1 here is the equivalent of CMD_PROP_TX
    .numHdrBits         = 8, // 8 here is the equivalent of CMD_PROP_TX
    .pktLen             = 0x0000,

		.startConf.bExtTxTrig   = 0,
    .startConf.inputMode    = 0,
    .startConf.source       = 0,
    .preTrigger.triggerType = TRIG_NOW,
    .preTrigger.bEnaCmd     = 0,
    .preTrigger.triggerNo   = 0,
    .preTrigger.pastTrig    = 1,
    .preTime                = 0,

		//.syncWord = 0x930B51DE,
    .syncWord = 0x333C3C33,
    .pPkt = 0, // INSERT APPLICABLE POINTER: (uint8_t*)&xxx
};

void radioSetup_setFastLRM(uint32_t i) {
	radio_mode              [i] = radio_mode_fastlrm              ;
	radio_cmd_prop_div_setup[i] = radio_cmd_prop_div_setup_fastlrm;
	radio_cmd_prop_tx       [i] = radio_cmd_prop_tx_fastlrm       ;
	radio_cmd_prop_tx_adv   [i] = radio_cmd_prop_tx_adv_fastlrm   ;
	radio_cmd_prop_rx       [i] = radio_cmd_prop_rx_fastlrm       ;
	radio_cmd_fs            [i] = radio_cmd_fs_fastlrm            ;
}

/***************************************************************/
#endif

#if MOVED_TO_RADIO_C
uint8_t  radioSetupDataProtocol[ MAX_RADIO_SETUPS ];
uint8_t radioSetupsCount;
//void radioSetup_configureFromBuffer(const uint32_t* radioData, uint16_t radioDataLength) {
//	 uint8_t* p = (uint8_t*) radioData;
void radioSetup_configureFromBuffer(const uint8_t* radioData, uint16_t radioDataLength) {
	 const uint8_t* p = radioData;
/*
	 uint8_t dataProtocol = DATA_PROTOCOL_ATLAS; // 8 bits
	 uint8_t modulation   = MODULATION_TYPE_FSK; // 2 bits
	 uint8_t txPower      = 10;                  // 6 bits signed
	 uint8_t msbFirst     = 1;                   // 1 bit
	 uint8_t swBits       = 32;                  // 6 bits unsigned
	 uint8_t fecWhiten    = DATA_ENCODING_PLAIN;    // 8 bits
*/
	 //uint8_t i = 0;
	 radioSetupsCount = 0;

	 while ((p - (uint8_t*) radioData) < radioDataLength) {
		 uint8_t b;
		 uint8_t dataProtocol = *(p++); // 8 bits
		 b = *(p++);
		 uint8_t modulation   = (b >> 6) & 0x03; // 2 bits
		 uint8_t txPower      = (b & 0x3F) - 32; // 6 bits signed
		 b = *(p++);
		 uint8_t msbFirst     = (b >> 7);                   // 1 bit
		 uint8_t swBits       = (b & 0x3F);                 // 6 bits unsigned
		 uint8_t fecWhiten    = *(p++);    // 8 bits

		 uint32_t syncWord    = *( (uint32_t*) p ); p+=4;
		 uint32_t freq        = *( (uint32_t*) p ); p+=4;
		 uint32_t dev         = *( (uint32_t*) p ); p+=4;
		 uint32_t symbRate    = *( (uint32_t*) p ); p+=4;
		 uint32_t rxBw        = *( (uint32_t*) p ); p+=4;

		 //System_printf("%d>> %08x %d %d %d %d -- %d %d %d %d %d %d\n", radioSetupsCount, syncWord, freq, dev, symbRate, rxBw, dataProtocol,modulation,txPower,msbFirst,swBits,fecWhiten);

		 radioSetup_modulation  (radioSetupsCount, modulation,symbRate,dev,rxBw);
		 radioSetup_txPower     (radioSetupsCount, txPower);
		 radioSetup_packetFormat(radioSetupsCount, fecWhiten); // this will override the number of preamble bytes in lrm mode 2
		 radioSetup_frequency   (radioSetupsCount, freq);

		 radioSetupDataProtocol[ radioSetupsCount ] = dataProtocol;
		 // sync word missing still

		 radioSetupsCount++;
	 }
	 //return radioSetupsCount;
}
#endif
// was in tag.c

uint32_t ratDiffToUs(uint32_t now, uint32_t rat_time) {
  if (now > rat_time) {
  	return ((UINT_MAX - now) + rat_time) / 4; // microseconds to wrap around, because RAT runs at 4MHz
  } else {
  	return (rat_time - now) / 4;
  }
}

/**************************************************************************************/
/* Callable radio action functions                                                    */
/**************************************************************************************/

/*
  Error handling function  replaces the default while(1) in RF driver.
  This is necessary for certain versions of TI-RTOS, not all; see
  http://processors.wiki.ti.com/index.php/CC1310_rev_B_PCN_information
*/
static void errorCallback(RF_Handle h, RF_CmdHandle ch, RF_EventMask e) {
    if ((int32_t)ch == RF_ERROR_CMDFS_SYNTH_PROG) {
        // Handle error
        // If CMD_FS is executed standalone, re-start CMD_FS in this function if there is time. If not, handle as in previous example
        // When CMD_FS is chained with RX/TX commands, the RX/TX is executed in parallel with this callback by the radio and will subsequently fail. Error can be handled as in previous example.
    }
}

static RF_Object rfObject;
static RF_Handle rfHandle;
//static uint8_t radioOpen = 0;
static RF_CmdHandle rxcmd = 0;
static uint8_t radioSetupInUse = 0xFF; // radio not actually in use

//#define RF_SWITCH_COUNT 0

static const PIN_Config pinTable[] = {
#ifdef RF_SWITCH_0
  RF_SWITCH_0 | PIN_GPIO_OUTPUT_EN | RF_SWITCH_0_INITIAL | PIN_PUSHPULL | PIN_DRVSTR_MAX,
//#define RF_SWITCH_COUNT 1
#endif

#ifdef RF_SWITCH_1
  RF_SWITCH_1 | PIN_GPIO_OUTPUT_EN | RF_SWITCH_1_INITIAL | PIN_PUSHPULL | PIN_DRVSTR_MAX,
//#define RF_SWITCH_COUNT 2
#endif

#ifdef RF_SWITCH_2
  RF_SWITCH_2 | PIN_GPIO_OUTPUT_EN | RF_SWITCH_2_INITIAL | PIN_PUSHPULL | PIN_DRVSTR_MAX,
//#define RF_SWITCH_COUNT 3
#endif

  PIN_TERMINATE
};

static PIN_Handle rfPinHandle;
static PIN_State  rfPinState;

int radioInit() {

    rfPinHandle = PIN_open(&rfPinState, pinTable);
    if(!rfPinHandle) {
      System_abort("Error initializing board RF switch pins\n");
    }
    System_printf("RF switch pins configured\n");
    return 0;
}

static uint8_t current_pa = 0;
static uint8_t current_lo = 0;

int radioPrepare(uint8_t setup, int invert, int tx, int8_t dbm) {
  current_lo = loForSetup[setup];
  int sub1GHz    = (current_lo > 2);

  System_printf("prepare1 %d dbm %d\n",setup,dbm);

  switch (dbm) {
  case RADIO_DBM_KEEP: // for rx after tx
      dbm = dbmForSetup[setup];
      break;
  case RADIO_DBM_DEFAULT: // for basestations
#if defined(CC2652P)
      if (sub1GHz) dbm = 14;
      else         dbm = 20;
#elif defined(CC1352P1)
      if (sub1GHz) dbm = 20;
      else         dbm = 5;
#else
      if (sub1GHz) dbm = 14;
      else         dbm = 5;
#endif
      break;
  default:
      break;
  }

  //System_printf("prepare2 %d dbm %d\n",setup,dbm);
  //consoleFlush();

  dbmForSetup[setup] = dbm;

#ifdef DeviceFamily_CC13X2
  current_pa = 0;
  if (!sub1GHz && dbm > 5 ) current_pa = 1;
  if ( sub1GHz && dbm > 14) current_pa = 1;
  System_printf("x pa %d dbm %d lo %d\n",current_pa,dbm,current_lo);
  //consoleFlush();
#endif

  //System_printf("prep 1 s %d\n",setup);
  //consoleFlush();

  radioSetup_txPower(setup, dbm);

  //System_printf("prep 2\n");
  //consoleFlush();

  //System_printf("configuring radio setup\n");

  //if (radioSetupInUse != setup || ((invert == RADIO_INVERT_BITS) != ((radio_cmd_prop_div_setup[setup]).formatConf.bBitReversal == 0x1)) ) {

    //if (radioOpen) RF_close(rfHandle);

    //radioOpen = 1;
    radioSetupInUse = setup;

    if (invert == RADIO_INVERT_BITS)
      (radio_cmd_prop_div_setup[setup]).formatConf.bBitReversal = 0x1;
    else
      (radio_cmd_prop_div_setup[setup]).formatConf.bBitReversal = 0x0;

    //System_printf("prep 3\n");
    //consoleFlush();

    /* Request access to the radio */
    RF_Params rfParams;
    RF_Params_init(&rfParams);
    //rfParams.nInactivityTimeout = 100; // in usecs
    rfParams.nInactivityTimeout = 250; // in usecs; was 100
    rfParams.pErrCb = errorCallback; // only necessary in certain versions of TI-RTOS

    //System_printf("prep 4\n");
    //consoleFlush();

    rfHandle = RF_open(&rfObject, &(radio_mode[setup]), (RF_RadioSetup*)&(radio_cmd_prop_div_setup[setup]), &rfParams);

#ifdef OLD
    System_printf("prep 5 s %d %04x lo %d pw %04x\n",
                  setup,
                  (radio_cmd_prop_div_setup[setup]).commandNo,
                  loForSetup[setup],
                  (radio_cmd_prop_div_setup[setup]).txPower);
    consoleFlush();
#endif

    // Sivan Sep 2019: I think that this is not needed because RF_open causes this to be called when the radio wakes up
    RF_runCmd(rfHandle, (RF_Op*)&(radio_cmd_prop_div_setup[setup]), RF_PriorityNormal, NULL, 0);
    if ((radio_cmd_prop_div_setup[setup]).status != PROP_DONE_OK) System_printf("CMD_SETUP> %04x\n",(radio_cmd_prop_div_setup[setup]).status);

    //System_printf("prep 5\n");
    //consoleFlush();

    /* Set the frequency */
    RF_runCmd(rfHandle, (RF_Op*)&(radio_cmd_fs[setup]), RF_PriorityNormal, NULL, 0);
  //}
    //System_printf("prep done\n");
    //consoleFlush();
    return 0;
}

void radioReceiveStop() {
    if (rxcmd==0) return;
  //if (radioOpen) { // meaning we are in rx
    RF_cancelCmd(rfHandle,rxcmd,0 /* 0=abrupt; 1=gracefull */);
    RF_close(rfHandle);
    rxcmd = 0;
    System_printf("rf close (rx stop)\n");
    //radioOpen = 0;
  //}

#ifdef RF_SWITCH_0
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_0, RF_SWITCH_0_OFF);
#endif
#ifdef RF_SWITCH_1
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_1, RF_SWITCH_1_OFF);
#endif
#ifdef RF_SWITCH_2
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_2, RF_SWITCH_2_OFF);
#endif

}

void radioShutdown() {
  //if (radioOpen) {
    RF_close(rfHandle);
    System_printf("rf close (shutdown)\n");
  //  radioOpen = 0;
  //}

#ifdef RF_SWITCH_0
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_0, RF_SWITCH_0_OFF);
#endif
#ifdef RF_SWITCH_1
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_1, RF_SWITCH_1_OFF);
#endif
#ifdef RF_SWITCH_2
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_2, RF_SWITCH_2_OFF);
#endif

}

int radioReceiveStart() {

    int sub1GHz    = (current_lo > 2);

    if ( sub1GHz ) {
        ///System_printf("RF switch: sub1GHz RX %d %d %d\n",RF_SWITCH_0_SUB1GHZ_RX,RF_SWITCH_1_SUB1GHZ_RX,RF_SWITCH_2_SUB1GHZ_RX);
#ifdef RF_SWITCH_0
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_0, RF_SWITCH_0_SUB1GHZ_RX);
#endif
#ifdef RF_SWITCH_1
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_1, RF_SWITCH_1_SUB1GHZ_RX);
#endif
#ifdef RF_SWITCH_2
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_2, RF_SWITCH_2_SUB1GHZ_RX);
#endif
    } else {
        //System_printf("RF switch: 2.4GHz RX\n");
#ifdef RF_SWITCH_0
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_0, RF_SWITCH_0_2_4GHZ_RX);
#endif
#ifdef RF_SWITCH_1
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_1, RF_SWITCH_1_2_4GHZ_RX);
#endif
#ifdef RF_SWITCH_2
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_2, RF_SWITCH_2_2_4GHZ_RX);
#endif
    }

  /* Modify CMD_PROP_RX command for application needs */
  (radio_cmd_prop_rx[radioSetupInUse]).status = IDLE;
  (radio_cmd_prop_rx[radioSetupInUse]).pQueue = &dataQueue;           /* Set the Data Entity queue for received data */
  (radio_cmd_prop_rx[radioSetupInUse]).rxConf.bAutoFlushIgnored = 1;  /* Discard ignored packets from Rx queue */
  (radio_cmd_prop_rx[radioSetupInUse]).rxConf.bAutoFlushCrcErr = 1;   /* Discard packets with CRC error from Rx queue */
  (radio_cmd_prop_rx[radioSetupInUse]).maxPktLen = BUFFER_SIZE-NUM_APPENDED_BYTES-1;
  (radio_cmd_prop_rx[radioSetupInUse]).pktConf.bRepeatOk  = 0; // End operation after receiving a packet correctly
  (radio_cmd_prop_rx[radioSetupInUse]).pktConf.bRepeatNok = 1; // Go back to sync search after receiving a packet with CRC error

  /* Enter RX mode and stay forever in RX */
  //RF_runCmd(rfHandle, (RF_Op*)&(radio_cmd_prop_rx[radio_setup]), RF_PriorityNormal, &callback, IRQ_RX_ENTRY_DONE);
  //RF_postCmd(rfHandle, (RF_Op*)&(radio_cmd_prop_rx[radio_setup]), RF_PriorityNormal, &receiveCallback, IRQ_RX_ENTRY_DONE);

  System_printf("posting rx\n");
  radio_cmd_prop_rx[radioSetupInUse].status = IDLE;
  rxcmd = RF_postCmd(rfHandle, (RF_Op*)&(radio_cmd_prop_rx[radioSetupInUse]), RF_PriorityNormal, &receiveCallback, IRQ_RX_ENTRY_DONE);

  return RADIO_SUCCESS;
}

int radioReceiveMessage(uint32_t howLongUs) {

    int sub1GHz    = (current_lo > 2);

    if ( sub1GHz ) {
        ///System_printf("RF switch: sub1GHz RX %d %d %d\n",RF_SWITCH_0_SUB1GHZ_RX,RF_SWITCH_1_SUB1GHZ_RX,RF_SWITCH_2_SUB1GHZ_RX);
#ifdef RF_SWITCH_0
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_0, RF_SWITCH_0_SUB1GHZ_RX);
#endif
#ifdef RF_SWITCH_1
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_1, RF_SWITCH_1_SUB1GHZ_RX);
#endif
#ifdef RF_SWITCH_2
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_2, RF_SWITCH_2_SUB1GHZ_RX);
#endif
    } else {
        //System_printf("RF switch: 2.4GHz RX\n");
#ifdef RF_SWITCH_0
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_0, RF_SWITCH_0_2_4GHZ_RX);
#endif
#ifdef RF_SWITCH_1
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_1, RF_SWITCH_1_2_4GHZ_RX);
#endif
#ifdef RF_SWITCH_2
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_2, RF_SWITCH_2_2_4GHZ_RX);
#endif
    }

    rfc_propRxOutput_t rxout; // not sure it's needed

  (radio_cmd_prop_rx[radioSetupInUse]).status = IDLE;
  (radio_cmd_prop_rx[radioSetupInUse]).startTrigger.triggerType = TRIG_NOW;
  (radio_cmd_prop_rx[radioSetupInUse]).pQueue = &dataQueue;
  (radio_cmd_prop_rx[radioSetupInUse]).pOutput = (uint8_t*) &rxout;
  (radio_cmd_prop_rx[radioSetupInUse]).maxPktLen = 100; // XXX why?
  (radio_cmd_prop_rx[radioSetupInUse]).rxConf.bAutoFlushIgnored = 1;  /* Discard ignored packets from Rx queue */
  (radio_cmd_prop_rx[radioSetupInUse]).rxConf.bAutoFlushCrcErr = 1;   /* Discard packets with CRC error from Rx queue */
  (radio_cmd_prop_rx[radioSetupInUse]).pktConf.bRepeatOk = 0; // return if we received a packet
  (radio_cmd_prop_rx[radioSetupInUse]).pktConf.bRepeatNok = 1;
  (radio_cmd_prop_rx[radioSetupInUse]).pktConf.endType = 1; // stop rx when end trigger arrives
  (radio_cmd_prop_rx[radioSetupInUse]).endTrigger.triggerType  = TRIG_REL_START; // xyz TRIG_ABSTIME;
  (radio_cmd_prop_rx[radioSetupInUse]).endTime                 = 4*howLongUs;

  RF_runCmd(rfHandle, (RF_Op*)&(radio_cmd_prop_rx[radioSetupInUse]), RF_PriorityNormal, NULL, 0);

  RF_close(rfHandle);

#ifdef RF_SWITCH_0
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_0, RF_SWITCH_0_OFF);
#endif
#ifdef RF_SWITCH_1
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_1, RF_SWITCH_1_OFF);
#endif
#ifdef RF_SWITCH_2
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_2, RF_SWITCH_2_OFF);
#endif

  System_printf("rf close (rx msg)\n");

  switch (radio_cmd_prop_rx[radioSetupInUse].status) {
  case PROP_DONE_OK:
    return RADIO_SUCCESS;
  case ERROR_PAST_START:
    return RADIO_PAST_START;
  case PROP_DONE_RXTIMEOUT:
    return RADIO_RX_TIMEOUT;
  default:
    return RADIO_ERROR;
  }
}

int radioTransmit(uint8_t* packet, int length, int scheduleType, uint32_t timestamp, int32_t offset) {

    int sub1GHz    = (current_lo > 2);

    if ( sub1GHz && !current_pa) {
        //System_printf("RF switch: sub1GHz TX %d %d %d\n",RF_SWITCH_0_SUB1GHZ_TX,RF_SWITCH_1_SUB1GHZ_TX,RF_SWITCH_2_SUB1GHZ_TX);
#ifdef RF_SWITCH_0
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_0, RF_SWITCH_0_SUB1GHZ_TX);
#endif
#ifdef RF_SWITCH_1
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_1, RF_SWITCH_1_SUB1GHZ_TX);
#endif
#ifdef RF_SWITCH_2
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_2, RF_SWITCH_2_SUB1GHZ_TX);
#endif
    }
    if ( sub1GHz && current_pa ) {
        //System_printf("RF switch: sub1GHz TX PA %d %d %d\n",RF_SWITCH_0_SUB1GHZ_TX_PA,RF_SWITCH_1_SUB1GHZ_TX_PA,RF_SWITCH_2_SUB1GHZ_TX_PA);
#ifdef RF_SWITCH_0
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_0, RF_SWITCH_0_SUB1GHZ_TX_PA);
#endif
#ifdef RF_SWITCH_1
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_1, RF_SWITCH_1_SUB1GHZ_TX_PA);
#endif
#ifdef RF_SWITCH_2
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_2, RF_SWITCH_2_SUB1GHZ_TX_PA);
#endif
    }

    if (!sub1GHz && current_pa) {
        //System_printf("RF switch: 2.4GHz TX PA\n");
#ifdef RF_SWITCH_0
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_0, RF_SWITCH_0_2_4GHZ_TX_PA);
#endif
#ifdef RF_SWITCH_1
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_1, RF_SWITCH_1_2_4GHZ_TX_PA);
#endif
#ifdef RF_SWITCH_2
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_2, RF_SWITCH_2_2_4GHZ_TX_PA);
#endif
    }
    if (!sub1GHz && !current_pa) {
        //System_printf("RF switch: 2.4GHz TX\n");
#ifdef RF_SWITCH_0
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_0, RF_SWITCH_0_2_4GHZ_TX);
#endif
#ifdef RF_SWITCH_1
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_1, RF_SWITCH_1_2_4GHZ_TX);
#endif
#ifdef RF_SWITCH_2
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_2, RF_SWITCH_2_2_4GHZ_TX);
#endif
    }

#ifdef RAT_WRAPAROUND_FIX
  uint32_t rat_now = RF_getCurrentTime();
  uint32_t wait_us = ratDiffToUs(rat_now,ts);

  /* Make sure no RAT wrap around occurs while we wait for RAT; it does not work */
  if (rat_now > ts) { // wrap around
    if (wait_us > 10000) // more than 10ms? if so, sleep until 10ms before deadline
      Task_sleep((wait_us-10000) / Clock_tickPeriod);
  }
#endif

  if (length <= 255) {
    (radio_cmd_prop_tx[radioSetupInUse]).status = IDLE;
    (radio_cmd_prop_tx[radioSetupInUse]).pktLen = length;
    (radio_cmd_prop_tx[radioSetupInUse]).pPkt   = packet;
    switch (scheduleType) {
    case RADIO_SCHEDULE_NOW:
      (radio_cmd_prop_tx[radioSetupInUse]).startTrigger.triggerType = TRIG_NOW;
      (radio_cmd_prop_tx[radioSetupInUse]).startTrigger.pastTrig = 1;
      (radio_cmd_prop_tx[radioSetupInUse]).startTime = 0;
      break;
    case RADIO_SCHEDULE_REL_TS:
      (radio_cmd_prop_tx[radioSetupInUse]).startTrigger.triggerType = TRIG_ABSTIME;
      (radio_cmd_prop_tx[radioSetupInUse]).startTrigger.pastTrig = 1;
      (radio_cmd_prop_tx[radioSetupInUse]).startTime = timestamp + (offset*4); // offset in us, RAT at 4MHz
      break;
    case RADIO_SCHEDULE_REL_NOW:
      (radio_cmd_prop_tx[radioSetupInUse]).startTrigger.triggerType = TRIG_REL_SUBMIT;
      (radio_cmd_prop_tx[radioSetupInUse]).startTrigger.pastTrig = 1;
      (radio_cmd_prop_tx[radioSetupInUse]).startTime = (offset*4); // offset in us, RAT at 4MHz
      break;
    }
    RF_EventMask result = RF_runCmd(rfHandle, (RF_Op*)&(radio_cmd_prop_tx[radioSetupInUse]), RF_PriorityNormal, NULL, 0);

    RF_close(rfHandle);

#ifdef RF_SWITCH_0
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_0, RF_SWITCH_0_OFF);
#endif
#ifdef RF_SWITCH_1
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_1, RF_SWITCH_1_OFF);
#endif
#ifdef RF_SWITCH_2
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_2, RF_SWITCH_2_OFF);
#endif

        //System_printf("rf close (tx)\n");

    //System_printf("tx s1g %d pa %d pins %d %d %d\n",sub1GHz,current_pa,PIN_getOutputValue(RF_SWITCH_0), PIN_getOutputValue(RF_SWITCH_1), PIN_getOutputValue(RF_SWITCH_2)); // length);

    switch ((radio_cmd_prop_tx[radioSetupInUse]).status) {
    case PROP_DONE_OK:
      return RADIO_SUCCESS;
    case ERROR_PAST_START:
      return RADIO_PAST_START;
    default:
      System_printf("tx err %0x\n",(radio_cmd_prop_tx[radioSetupInUse]).status);
      return RADIO_ERROR;
    }
  } else {
    //int x=0, y=0, z=0;
    (radio_cmd_prop_tx_adv[radioSetupInUse]).status = IDLE;
    (radio_cmd_prop_tx_adv[radioSetupInUse]).pPkt   = packet;
    (radio_cmd_prop_tx_adv[radioSetupInUse]).pktLen = length;

    switch (scheduleType) {
    case RADIO_SCHEDULE_NOW:
      (radio_cmd_prop_tx_adv[radioSetupInUse]).startTrigger.triggerType = TRIG_NOW;
      (radio_cmd_prop_tx_adv[radioSetupInUse]).startTrigger.pastTrig = 1;
      (radio_cmd_prop_tx_adv[radioSetupInUse]).startTime = 0;
      //x=1;
      break;
    case RADIO_SCHEDULE_REL_TS:
      (radio_cmd_prop_tx_adv[radioSetupInUse]).startTrigger.triggerType = TRIG_ABSTIME;
      (radio_cmd_prop_tx_adv[radioSetupInUse]).startTrigger.pastTrig = 1;
      (radio_cmd_prop_tx_adv[radioSetupInUse]).startTime = timestamp + (offset*4); // offset in us, RAT at 4MHz
      //x=2;
      break;
    case RADIO_SCHEDULE_REL_NOW:
      (radio_cmd_prop_tx_adv[radioSetupInUse]).startTrigger.triggerType = TRIG_REL_SUBMIT;
      (radio_cmd_prop_tx_adv[radioSetupInUse]).startTrigger.pastTrig = 1;
      (radio_cmd_prop_tx_adv[radioSetupInUse]).startTime = (offset*4); // offset in us, RAT at 4MHz
      //x=3;
      break;
    }

    RF_EventMask result = RF_runCmd(rfHandle, (RF_Op*)&(radio_cmd_prop_tx_adv[radioSetupInUse]), RF_PriorityNormal, receiveCallback, 0);

    RF_close(rfHandle);

#ifdef RF_SWITCH_0
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_0, RF_SWITCH_0_OFF);
#endif
#ifdef RF_SWITCH_1
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_1, RF_SWITCH_1_OFF);
#endif
#ifdef RF_SWITCH_2
        PIN_setOutputValue(rfPinHandle, RF_SWITCH_2, RF_SWITCH_2_OFF);
#endif

    //System_printf("rf close (tx adv)\n");

    //System_printf("tx s1g %d pa %d pins %d %d %d\n",sub1GHz,current_pa,PIN_getOutputValue(RF_SWITCH_0), PIN_getOutputValue(RF_SWITCH_1), PIN_getOutputValue(RF_SWITCH_2)); // length);

    switch ((radio_cmd_prop_tx_adv[radioSetupInUse]).status) {
    case PROP_DONE_OK:
      System_printf("ADV ok %d\n",length);
      return RADIO_SUCCESS;
    case ERROR_PAST_START:
      System_printf("ADV past %d\n",length);
      return RADIO_PAST_START;
    default:
      System_printf("ADV e %d %08x\n",length,(radio_cmd_prop_tx_adv[radioSetupInUse]).status);
      return RADIO_ERROR;
    }
  }
}

/**************************************************************************************/
/**************************************************************************************/
/**************************************************************************************/
#endif // we are using the CC13XX built-in radio
